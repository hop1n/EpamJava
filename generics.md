В какой версии Java появились параметризованные типы?
Ответ. В J2SE 5.
Источник. И. Блинов. Методы программирования. с. 68


Приведите 2 примера кода: первый без параметризованного типа; второй - этот же код с параметризованным типом, иллюстрирующий преимущество данного варианта. 
Ответ. Пример без параметризированного типа:
List list = new ArrayList();
list.add("hello");
list.add(3); // можно добавить другой тип в коллекцию, что чревато ошибками
String s = (String) list.get(0); // необходимо приведение типа

Пример с параметризованным типом:
List<String> list = new ArrayList<String>();
list.add("hello");
list.add(3); // ошибка компиляции
String s = list.get(0);   // преимущество: не нужно приведение типа
Источник. https://docs.oracle.com/javase/tutorial/java/generics/why.html

Какие типы данных запрещены в качестве параметров классов?
Ответ.  Примитивные типы.
Источник. И. Блинов. Методы программирования. с. 68

Дан код:
class Gen <T1, T2 extends Number, T3 extends Object> { … }
Какие типы можно использовать в качестве аргументов T1, T2, T3?
Ответ. В качестве T1 и T3 можно использовать любые ссылочные типы, T2 - только класс Number и его подклассы.
Источник. И. Блинов. Методы программирования. с. 68


Дан код:
class Gen1 <T> { … }
class Gen2 <T extends Object> { … }
class Runner {
	private final static Gen1<Object> g11 = new Gen1<>();
	private final static Gen1 g12 = new Gen1();
	private final static Gen2<Object> g21 = new Gen2<>();
	private final static Gen2 g22 = new Gen2();
	...
}
В чем различие объявления классов Gen1 и Gen2?
Есть ли преимущество в объявлении g11 по сравнению с g12? Обоснуйте ответ. 
Есть ли преимущество в объявлении g21 по сравнению с  g12? Обоснуйте ответ. 
В каком случае используется второй способ (g12, g22)? 
Ответ. 
Объявления классов Gen1 и Gen2 в данном случае эквивалентны, т.к. все классы наследуются от класса Object. Но если бы вместо Object стоял другой класс, например Number, то запись <T extends Number> говорила бы нам о том, что в качестве типа Т разрешено применять только классы, являющиеся подклассами класса Number, и, соответственно, появлялась бы возможность вызова методов ограничивающих типов.

При объявлении объектов g11 и g21 обеспечивается типобезопасность. В случае g12, g22 не выполняется никакой проверки типов, в то время как в случае g11, g21 точно сообщается компилятору, что параметром может быть объект любого типа. Использование сырых типов (Gen1 g12, Gen2 g22) может привести к исключениям во время выполнения, они не безопасны. Сырые типы существуют лишь для для совместимости и взаимодействия с кодом, написанным до появления средств обобщённого программирования.

Способы объявления g12 и g22 необходим для обеспечения совместимости с кодом, созданным в предыдущих версиях языка Java.
Источник. И. Блинов. Методы программирования. с. 70
Джошуа Блох «Effective Java» статья 23


Дан код:
class SubInfo extends Info { … }
class Gen1 <T> { … }
class Gen2 <T extends Info> { … }
1.	Является ли декларация Gen1<Info> подклассом Gen2<Info>?
2.	Является ли декларация Gen1<SubInfo> подклассом Gen1<Info>?
3.	Является ли декларация Gen2<SubInfo> подклассом Gen2<Info>?
Ответ. 1.Нет 2. Нет 3. Нет

Почему нельзя вызвать конструктор generic-типа?
Ответ. Компилятор не знает, какой конструктор может быть вызван и какой объем памяти должен быть выделен при создании объекта.
Источник. И. Блинов. Методы программирования. с. 72

Почему нельзя создать generic-поле?
Почему статический метод не может иметь generic-параметр?
Ответ. По аналогичным причинам (см. Вопрос выше) generic-поля не могут быть статическими, статические методы не могут иметь generic-параметры или обращаться к generic-полям. Статический метод может иметь generic-параметр, только если он не является generic-параметром класса.
Источник. И. Блинов. Методы программирования. с. 72

Предложите более эффективную запись данного кода:
<T> void make1(Gen <T extends Object> gen) { … }
<T, S extends T> void make2(Info<T> info1, Info<S> info2) { … }
Ответ. 
<T> void make1(Gen <T> gen) { … }
<T> void make2(Info<T> info1, Info<? extends T> info2) { … }

Дан код:
class Info { 
	public <T1> Info() { … }
	public <T2> Info(T2 t2) { … }
	public <T1> void make1(T1 t1) { … }
	public <T3> void make2() { … }
}
Создайте какой-либо экземпляр класса Info 
1.	конструктором без аргументов, 
2.	конструктором с аргументом.
Синтаксически правильно вызовите методы make1() и make2().
Ответ.
	public static void main(String[] args) {
		Info one = new <String>Info();
		Info two = new <String>Info("test");
		one.<String>make1("test");
		one.<Integer>make2();
		two.<Integer>make1(2);
		two.<Double>make2();
	}


Поясните данный код:
static <T extends Object & Comparable<? super T>> T max(Collection<? extends T> coll)
Ответ. Метод возвращает максимальный элемент в коллекции coll в соответствии с естественным упорядочением её элементов. Все элементы в коллекции должны реализовывать интерфейс Comparable. Кроме того, все элементы в коллекции должны быть взаимно сопоставимыми (то есть вызов метода e1.compareTo(e2) не должен выбрасывать исключение ClassCastException для любых элементов e1 и e2 в коллекции). Этот метод выполняет итерацию по всей коллекции, поэтому требует времени, пропорционального размеру коллекции.
Такая декларация метода max необходима, чтобы его можно было использовать для коллекций типов (назовем эти типы X), которые не реализуют Comparable<X>, но реализуют Comparable<некий суперкласс X>. 
Это декларация метода java.util.Collections.max().

Источник: https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Collections.html#max(java.util.Collection)
