Вопрос 1.  
Что появится в консоли в результате работы фрагмента программы?
```java
String a = "java";
a.toUpperCase();
System.out.println(a);
```
**Ответ.** В консоли появится содержимое переменной `а` при её объявлении, а именно текст `java`. Вторая строка `a.toUpperCase()` отработает, но не изменит содержимое `а`, так как класс `String` является `immutable` и при любых операциях приводящих к изменению содержимого строки возвращает новую строку, которая при выполнении `a.toUpperCase()` никуда не сохраняется.  
**Источник.** https://docs.oracle.com/javase/tutorial/java/data/strings.html

Вопрос 2.
Что появится в консоли в результате работы фрагмента программы?
```java
String s1 = "Java";
String s2 = "Java";
String s3 = new String("Java");
System.out.println("s1 == s2 : " + (s1 == s2));
System.out.println("s1 == s3 : " + (s1 == s3));
System.out.println(s1.equals(s3));
```
Поясните ответ.  
**Ответ.**  
а)`s1 == s2 : true`  
Так как в `Java` все ссылки хранятся в стеке, а объекты — в `heap`, то при создании объектов `s1`, `s2` сначала создается ссылка, а затем этой ссылке устанавливается в соответствие объект. В данной ситуации `s2` ассоциируется с уже существующим литералом, так как объект `s1` уже сделал ссылку на этот литерал.  
б)`s1 == s3 : false`  
При создании `s3` происходит вызов конструктора, т.е. выделение памяти происходит раньше инициализации, и в этом случае в куче создается новый объект. При сравнении строк `s1` и `s3` через `==` будут сравниваться их ссылки, которые указывают на разные объекты.  
с)`true`  
При сравнении объектов через `equals` происходит сравнение по-содержимому, а не по ссылке. Так как содержимое строк в данному случае одинаковое то мы получаем `true`.  
**Источник.** Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик, 2020. – 230 с.

Вопрос 3.  
Можно ли выполнить наследование от класса String? Почему?  
**Ответ.** Класс `String` является `immutable` классом, что предполагает не только его неизменяемость, но и запрещает возможность наследоваться от него установкой `final`.
```java
public final class String
            implements java.io.Serializable, Comparable<String>, CharSequence {}
```
**Источник.** https://docs.oracle.com/javase/tutorial/java/data/strings.html

Вопрос 4.  
Назовите основные, на ваш взгляд, методы класса `String`.  
**Ответ.**  
`String concat(String s) или оператор «+»` — слияние строк;  
`boolean equals(Object ob) и equalsIgnoreCase(String s)` — сравнение строк с учетом и без учета нижнего и верхнего регистра символов соответственно;  
`int compareTo(String s) и compareToIgnoreCase(String s)` — лексикографическое сравнение строк с учетом и без учета их регистра. Метод осуществляет вычитание кодов первых различных символов вызывающей и передаваемой строки в метод строк и возвращает целое значение. Метод возвращает значение 0 в случае, когда equals() возвращает значение true;  
`boolean contentEquals(CharSequence ob)` — сравнение строки и содержимого объекта типа `StringBuffer`, `StringBuilder` и пр.;  
`boolean matches(String regex)` — проверка строки на соответствие регулярному выражению;  
`String  substring(int  n,  int  m)`  — извлечение из строки подстроки  длины `m-n`, начиная с позиции `n`. Нумерация символов в строке начинается с нуля;  
`String substring(int n)` — извлечение из строки подстроки, начиная с позиции `n`;  
`int length()` — определение длины строки;  
`int indexOf(char ch)` — определение позиции символа в строке;  
`static String valueOf(type v)` — преобразование переменной базового типа к строке;
`String toUpperCase()/toLowerCase() `— преобразование всех символов вызывающей строки в верхний/нижний регистр;  
`String replace(char с1, char с2)` — замена в строке всех вхождений первого символа вторым символом;  
`String replaceAll(String regex, String replacement)` — замена в строке всех подстрок, соответствующих регулярному выражению, новой строкой, см. также `replaceFirst()`;  
`String intern()` — заносит строку в «пул» литералов и возвращает ее объектную ссылку;  
`String strip()` — удаление всех пробелов в начале и конце строки, более совершенный аналог метода `trim()`;  
`char  charAt(int  position)`  —  возвращение  символа  из  указанной  позиции (нумерация с нуля);  
`boolean isEmpty()` — возвращает `true`, если длина строки равна 0;  
`boolean isBlank()` — возвращает `true`, если строка пуста или содержит только пробельные символы;  
`static  String  join(CharSequence  delimiter,  CharSequence...  elements)` — объединение  произвольного  набора  строк  (коллекции  строк)  в  одну  строку с заданной строкой-разделителем;  
`char[] getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)` — извлечение символов строки в массив символов;  
`static String format(String format, Object… args), format(Locale l, String format,  Object…  args)`  —  создание  форматированной  строки,  полученной с использованием формата, локализации и др.;  
`String[] split(String regex), String[] split(String regex, int limit)` — поиск вхождения в строку заданного регулярного выражения-шаблона в качестве разделителя и деление исходной строки в соответствии с этим разделителем на массив строк;  
`IntStream codePoints()` — извлечение символов строки в поток (stream) их кодов;  
`IntStream chars()` — преобразование строки в stream ее символов;  
`Stream<String> lines()` — извлечение строк, разделенных символом перехода на другую строку, в поток (stream) строк.  
**Источник.** Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик, 2020. – 226-227 с.

Вопрос 5.  
Какие разновидности конструкторов использует класс String?  
**Ответ.** Класс  String  поддерживает  несколько  конструкторов,  например:  `String(), String(String  original),  String(byte[]  bytes),  String(char[]  value),  String(char[] value, int offset, int count), String(StringBuffer buffer), String(StringBuilder builder)` и др. Эти конструкторы используются для создания объектов класса String на основе их инициализации значениями из массива типа `char, byte` и др.  
**Источник.** Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик, 2020. – 225 с.

Вопрос 6.  
Какие классы в стандартной библиотеке Java работают со строками?  
**Ответ.** Системная  библиотека  `Java`  содержит  классы  `String`,  `StringBuilder` и `StringBuffer`, поддерживающие хранение строк, их обработку и определенные в  пакете  `java.lang`,  подключаемом  к  приложению  автоматически.  Эти  классы объявлены как `final`, что означает невозможность создания собственных порожденных классов со свойствами строки. Для форматирования и обработки строк применяются также классы `Formatter, Pattern, Matcher, StringJoiner` и другие.  
**Источник.** Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик, 2020. – 225 с.

Вопрос 7.  
Почему экземпляры класса String в Java неизменные и финализированные?  
**Ответ.**   
Безопасность и String pool основные причины неизменяемости String в Java.  
Безопасность объекта неизменяемого класса String обусловлена такими фактами:  
•	вы можете передавать строку между потоками и не беспокоиться что она будет изменена  
•	нет проблем с синхронизацией (не нужно синхронизировать операции со String)  
•	отсутствие утечек памяти  
•	в Java строки используются для передачи параметров для авторизации, открытия файлов и т.д.
•   неизменяемость позволяет избежать проблем с доступом  
•	возможность кэшировать hash code  
String pool позволяет экономить память и не создавать новые объекты для каждой повторяющийся строки. В случае с изменяемыми строками - изменение одной приводило бы к изменению всех строк одинакового содержания.

Вопрос 8.  
Заполните ячейки таблицы (Да/Нет).  
**Ответ.**   
Characteristic 				    String		StringBuilder		StringBuffer  
Неизменяемый (Immutable)?	    Да		    Нет		        	Нет  
Имеет пул (Pooled)?			    Да	    	Нет			        Нет  
Потокобезопасный (Thread-safe)?	Да	    	Нет			        Да  
Может изменять размер?	    	Нет	    	Да			        Да  

Вопрос 9.  
В чем разница и что общего между StringBuffer и StringBuilder?  
**Ответ.** Основным отличием StringBuilder от StringBuffer является потокобезопасность последнего. Более высокая скорость обработки есть следствие отсутствия потокобезопасности класса StringBuilder. Его следует применять, если не существует вероятности использования объекта в конкурирующих потоках.  
**Источник.** Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик, 2020. – 231 с.

Вопрос 10.  
Когда лучше использовать StringBuffer, а когда StringBuilder?  
**Ответ.** Класс StringBuilder появился в java SE5. До этого использовался класс StringBuffer, который обеспечивал потоковую безопасность, поэтому операции с ним были связаны с большими затратами.  Соответственно, строковые операции в Java SE5/6 должны выполняться быстрее.  
**Источник.**  Философия  Java.  4-е  полное  изд. —  СПб.:  Питер,  2015.  —   418 c.

Вопрос 11.  
Какие методы имеются в классах StringBuffer и StringBuilder, которые отсутствуют в классе String?  
**Ответ.**  
`void setLength(int newLength)` — установка размера буфера;  
`void ensureCapacity(int minimumCapacity)` — установка гарантированного минимального размера буфера;  
`void trimToSize()` — сжатие буфера до размеров контента;  
`int capacity()` — возвращение текущего размера буфера;  
`StringBuffer  append(parameters)`  —  добавление  к  содержимому  объекта строкового представления аргумента, который может быть символом, значением базового типа, массивом и строкой;  
`StringBuffer  insert(parameters)`  —  вставка  символа,  объекта  или  строки в указанную позицию;
`StringBuffer  deleteCharAt(int  index)`  —  удаление  символа;  
`StringBuffer delete(int start, int end) `— удаление подстроки;  
`StringBuffer reverse()` — обращение содержимого объекта.  
**Источник.** Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик, 2020. – 232 с.

Вопрос 12.   
Какие методы сравнения строк имеются в строковых классах?  
**Ответ.** 
```
boolean endsWith(String suffix)  
boolean startsWith(String prefix)  	
boolean startsWith(String prefix, int offset)  	
int compareTo(String anotherString)	  
int compareToIgnoreCase(String str)	  
boolean equals(Object anObject)	  
boolean equalsIgnoreCase(String anotherString)  	
boolean regionMatches(int toffset, String other, int ooffset, int len)  	
boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len)  	
boolean matches(String regex)
```  
**Источник.** https://docs.oracle.com/javase/tutorial/java/data/comparestrings.html

Вопрос 13.   
Используя функции строковых классов, написать фрагмент программы, которая будет определять, является ли строка палиндромом.  
**Ответ.**  
```java
public static boolean isPalindrom(String text) {
    StringBuffer stringBuffer = new StringBuffer(text);
    return stringBuffer.reverse().toString().equals(text);
}
```

Вопрос 14.  
Что появится в консоли в результате работы фрагмента программы?  
```java
final String ZA = " за ";
String value = "ОТЧЕТ о перевозках пассажиров за январь 2019 г.";
String[] monthYear = value.split(ZA)[1].split(" ",3);
System.out.println(Arrays.toString(monthYear));
```
Поясните ответ.  
**Ответ.**  
[январь, 2019, г.]  
Первый `split(ZA)` разбивает строку `value` на 2 части до `ZA` (ОТЧЕТ о перевозках пассажиров за январь) и после `ZA` ( январь 2019 г.) создавая массив длинною 2. На втором шаге извлекается элемент массива под номером 1, т.е. последний элемент ( январь 2019 г.). Следующий `split(" ",3)` уже работает по извлеченной из массива строке ( январь 2019 г.) и разбивает её на новый массив по каждому пробелу, при этом 3 это лимит на количество разбитий (новых строк). В данном случае у нас совпадает количество пробелов в строке и если убрать 3 то результат вывода не изменится.
В итоге в консоль выводится содержимое массива из 3-х элементов в формате определенном `Arrays.toString`.

Вопрос 15.  
Что появится в консоли в результате работы фрагмента программы?  
```java
String s4 = "1" + 2 + 3;
String s5 = 1 + 2 + "3";
System.out.println(s4);
System.out.println(s5);
```
Поясните ответ.  
**Ответ.**   
`123`
Так как первый символ в выражении представляет строку то оператор `+` воспринимается как конкатенация строк, т.к. в классе String этот оператор переопределен.  
`33`  
Первый символ в выражении является числом и дальнейшее восприятие строки происходит как арифметическая операция `(1 + 2 = 3)`, следующий `+` уже воспринимается как конкатенация строк  т.к. “3”  является строкой.

Вопрос 16.  
Что появится в консоли в результате работы фрагмента программы?  
```java
String s = "abcde ";
System.out.println(s.trim().length());
System.out.println(s.charAt(4));
System.out.println(s.indexOf('e'));
System.out.println(s.indexOf("de"));
System.out.println(s.substring(2, 4).toUpperCase());
System.out.println(s.replace('a', '1'));
System.out.println(s.contains("DE"));
System.out.println(s.startsWith("a"));
```
Поясните ответ.  
**Ответ.**   
`5` – метод length() возвращает длину строки после операции обрезания пробельных символов методом trim() вначале и конце строки.  
`е` – метод charAt('e') возвращает символ в строке под индексом 4  
`4` -  метод indexOf() возвращает порядковый номер символа  
`3` -  метод indexOf("de") при такой записи возвращает индекс начала подстроки  
`CD` – метод substring(2, 4) возвращает подстроку с индекса 2 включительно до индекса 4, не включая индекс 4. Следующий метод toUpperCase()) переводит новую строку в верхний регистр.  
`1bcde` - Метод replace() заменяет все найденные в строке символы 'a' на '1';  
`false` - Метод contains() возвращает наличие либо отсутствие подстроки в исходной строке в виде булевого значения.  
`true` - Метод startsWith() возвращает наличие либо отсутствие в начале исходной строки переданной в метод строки.  

Вопрос 17.  
Что появится в консоли в результате работы фрагмента программы?  
```java
StringBuilder b = new StringBuilder();
b.append(12345).append('-');
System.out.println(b.length());
System.out.println(b.indexOf("-"));
System.out.println(b.charAt(2));
StringBuilder b2 = b.reverse();
System.out.println(b.toString());
System.out.println(b == b2);
```
Поясните ответ.  
**Ответ.**   
Создаётся объект класса StringBuilder в который последовательно передаются строки и склеиваются в одну.  
`6` - метод length() возвращает длину последовательности символов, представленных в данный момент этим объектом.  
`5` - Метод indexOf("-") возвращает индекс в строке первого вхождения указанной подстроки.  
`3` - Метод charAt(2)возвращает значение char в этой последовательности по указанному индексу.    
`-54321` - Метод reverse() производит замену последовательности символов на обратную последовательность причем результат сохраняется внутри b.  
`true` – через == происходит сравнение объектов по ссылки, а так как обе ссылки ссылаются на один объект то они равны.

Вопрос 18.  
Что появится в консоли в результате работы фрагмента программы?  
```java
StringBuilder s = new StringBuilder("abcde");
s.insert(1, '-').delete(3, 4);
System.out.println(s);
System.out.println(s.substring(2, 4));
```
Поясните ответ.  
**Ответ.**   
`a-bde`  
`bd`  
Метод `insert(1, '-')` вставляет в исходную строку `"abcde"` по индексу `1` символ `‘-‘` в итоге формирую последовательность `"a-bcde"`. После этого следующий метод delete(3, 4) уже в обновленной последовательности символов "a-bcde" удаляет символы с индекса `3` включительно до индекса `4` не включительно формируя последовательность `"a-bde"`.
Метод `substring(2, 4)` в обновленной последовательности `"a-bde"` возвращает последовательность с индекса `2` включительно по `4` не включительно.

Вопрос 19.  
```java
StringBuffer sb = new StringBuffer("abcde");
sb.insert(2,"123");
sb.append("456");
sb.reverse();
```
Поясните ответ.  
**Ответ.**   
`654edc321ba`  
Метод `insert(2,"123")` в исходную последовательность "abcde" пред символом под индексом 2 вставляет "123" формируя "ab123cde".  
Метод `append("456")` добавляет к "ab123cde" строку "456" формируя "ab123cde456".  
Метод `reverse()` разворачивает последовательность символов "ab123cde456" формируя "654edc321ba".  

Вопрос 20.  
Каким образом можно сцепить строки Java? Назовите не менее 3 способов.  
**Ответ.**   
Если брать только методы класса String то:
1) метод concat(String s)
2) метод join ()
3) скрытая конкатенация через переписанный оператор +.

Вопрос 21.   
Чем отличаются пустая и нулевая строки?  
**Ответ.** Пустая строка имеет представление как объект в пуле строк или heap, а нулевая строка не представлена объектом и имеет значение null.

Вопрос 22.   
В какой кодировке хранятся символы в строке?  
**Ответ.**  UTF-16  
**Источник.** https://docs.oracle.com/javase/7/docs/api/java/lang/String.html

Вопрос 23.   
Какие интерфейсы реализуют классы String, StringBuffer и StringBuilder?  
**Ответ.** 
```java
public final class String
    implements java.io.Serializable, Comparable<String>, CharSequence

public final class StringBuffer
    extends AbstractStringBuilder
    implements java.io.Serializable, Comparable<StringBuffer>, CharSequence

public final class StringBuilder
    extends AbstractStringBuilder
    implements java.io.Serializable, Comparable<StringBuilder>, CharSequence
```
Так как `StringBuffer` и `StringBuilder` наследуются от `AbstractStringBuilder` то они косвенно реализуют и интерфейсы реализуемые `AbstractStringBuilder implements Appendable, CharSequence`

Вопрос 24.   
Что такое кодовые точки и кодовые единицы?  
**Ответ.**   
Кодовой точкой  называется  значение,  связанное  с  символом  в  кодировке.  Согласно  стандар ту  на  Юникод,  кодовые  точки  записываются  в  шестнадцатеричной  форме  и  предваряются  символами  U+. Кодировка UTF-16  —  это способ представления в Юникоде всех кодовых точек кодом переменной длины.  Символы  из основной  многоязыковой  плоскости представляются 16-битовыми  значениями,  называемыми  кодовыми единицами. Дополнительные символы  обозначаются  последовательными  парами  кодовых единиц.  
**Источник.** Java. Библиотека профессионала, том 1. Основы. 10-е и з д .: Хорстманн, Кей С. 2016г – 68, 82-83 с.

Вопрос 25.   
Объясните назначение метода intern(). Что появится в консоли в результате работы фрагмента программы?  
```java
class GFG {
	public static void main(String[] args) {
		String s1 = new String("GFG");
		String s2 = s1.intern();
		System.out.println(s1 == s2);
		System.out.println(s1.equals(s2));
		String s3 = "GFG";
		System.out.println(s2 == s3);
	}
}
```
Поясните ответ.  
**Ответ.**   
`false`  
После операции s1.intern() вернулась ссылка на строку "GFG" из пула литералов, а ссылка s1 осталось неизменна. Т.е. это два разных объекта.  
`true`  
Происходит сравнение по содержимому объектов, а не по ссылке. Так как содержимое одинаково то и ответ true.   
`true`  
s2 и s3 ссылаются на строки из пула литералов, а так как в там может храниться только одна уникальная строка, то и ссылки на нее будут равны.  

Вопрос 26.  
Как преобразовать строку в число?  
**Ответ.** Использовать функционал классов оберток над примитивами, в частности метод valueOf().  
**Источник.** https://docs.oracle.com/javase/tutorial/java/data/converting.html

Вопрос 27.  
Какой метод вызывается для преобразования переменной в строку?  
**Ответ.** Явно и неявно любой объект преобразовывается в строку через метод toString() который наследуется для всех классов от Object.  

Вопрос 28.  
Каким методом в классе String можно проверить строку на соответствие регулярному выражению?  
**Ответ.** Для работы с регулярными выражениями у класса String есть метод matches() который сообщает, соответствует ли эта строка заданному регулярному выражению. Вызов этого метода в форме str.matches (regex) дает точно такой же результат, что и выражение Pattern.matches (regex, str).

Вопрос 29.  
Создайте класс с полями: int, long, float и double, String. Сделайте для этого класса метод toString(), использующий String.format(), и выведите содержимое полей на экран в произвольном порядке, используя спецификаторы.  
**Ответ.**  
```java
class DemoToString {
    int demoInt = 1;
    long demoLong = 2L;
    float demoFloat = 3.0f;
    double demoDouble = 4.0;
    String demoString = "demoString";

    @Override
    public String toString() {
        return String.format("%d %d %f %f %s", demoInt, demoLong, demoFloat, demoDouble, demoString);
    }

    public static void main(String[] args) {
        System.out.println(new DemoToString());
    }
}
```

Вопрос 30.  
Опишите:   
-назначение класса Formatter,   
-методы format(),   
-спецификаторы формата.  
**Ответ.**   
Для  создания  форматированного текстового  вывода  предназначен  класс `java.util.Formatter`. Этот класс обеспечивает преобразование формата, позволяющее выводить числа, строки, время и даты в любом необходимом разработчику виде. Класс  Formatter  преобразует  двоичную  форму  представления  данных в форматированный текст. Он сохраняет форматированный текст в буфере, содержимое  которого  можно  получить  в  любой  момент.  Можно  предоставить классу  Formatter  автоматическую  поддержку  этого  буфера  либо  задать  его явно при создании объекта.    
Некоторые методы класса:  
`Formatter format(Locale loc, String fmtString, Object…args)` — форматирует аргументы, переданные в аргументе переменной длины args, в соответствии со спецификаторами формата, содержащимися в fmtString. При форматировании используются региональные установки, заданные в lос. Возвращает вызывающий объект. Существует перегруженная версия метода без использования локализации format(String fmtString, Object…args);  
`Locale locale()` — возвращает региональные установки вызывающего объекта;  
`Appendable out()` — возвращает ссылку на базовый объект-приемник для выходных данных;  
`void flush()` — переносит информацию из буфера форматирования и производит запись в указанное место выходных данных, находящихся в буфере. Метод чаще всего используется объектом класса Formatter, связанным с файлом;  
`void close()` — закрывает вызывающий объект класса Formatter, что приводит  к  освобождению  ресурсов,  используемых  объектом.  После  закрытия объек та  типа  Formatter  он  не  может  использоваться  повторно.  Попытка ис пользовать  закрытый  объект  приводит  к  генерации  исключения  типа FormatterClosedException.  
Спецификатор формата  
`%a` Шестнадцатеричное значение с плавающей  точкой  
`%b` Логическое (булево) значение аргумента  
`%c` Символьное представление аргумента  
`%d` Десятичное целое значение аргумента  
`%h` Хэш-код аргумента  
`%e` Экспоненциальное представление аргумента  
`%f` Десятичное значение с плавающей точкой  
`%g` Выбирает более короткое представление из двух: %е или %f  
`%o` Восьмеричное целое значение аргумента  
`%n` Вставка символа новой строки  
`%s` Строковое представление аргумента  
`%t` Время и дата  
`%x` Шестнадцатеричное целое значение аргумента  
`%%` Вставка знака %  
Также возможны спецификаторы с заглавными буквами: %A (эквивалентно %a). Форматирование с их помощью обеспечивает перевод символов в верхний регистр.  
**Источник.** Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик, 2020. – 250-252 с.

Вопрос 31.  
Что представляет собой регулярное выражение?   
На каких классах базируются regex-возможности языка Java?   
В каком пакете эти классы расположены?    
**Ответ.**   
а)Регулярные выражения или шаблоны используются для поиска подстроки или строки, соответствующей шаблону в строке, тексте или другом объекте, представляющем последовательность символов.   
б)Класс Pattern и Matcher  
в)Пакет java.util.regex.*  
**Источник.** Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик, 2020. – 234с.

Вопрос 32.   
Опишите назначение классов Pattern и Matcher.   
Каким образом они связываются?   
Предоставить простейший код их взаимодействия.  
**Ответ.**   
а)Класс java.util.regex.Pattern применяется для создания этого объекта-шаблона. Для определения шаблона применяются специальные синтаксические конструкции. О каждом соответствии можно получить информацию с помощью класса java.util.regex.Matcher.  
б)Класс Pattern используется для простой обработки строк и объекта хранителя регулярного выражения. Объект класса Pattern, в свою очередь, исполь зуется  для  более  сложной  обработки  символьной  информации  классом Matcher.  
в)  
```java
Pattern pattern = Pattern.compile("x+y");
Matcher matcher = pattern.matcher("xxxy");
boolean res = matcher.matches(); 
System.out.println(res);
```  
**Источник.** Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик, 2020. – 234-236с.

Вопрос 33.  
При помощи регулярных выражений найти все ссылки внутри веб-страницы, то есть адреса, указанные в атрибуте href.  
**Ответ.**  
```java
public class RegexDemo {
    private static String REGEX = "href=\"([^>]*)\">";
    private static String INPUT = "<p><a href=\"https://docs.oracle.com/javase\">Cсылка 1</a></p>"
                                  + " <p><a href=\"http://htmlbook.ru/example/knob.html\">Cсылка 2</a></p>";
    public static void main(String[] args) {
        Pattern p = Pattern.compile(REGEX);
        Matcher m = p.matcher(INPUT);
        while (m.find()) {
            System.out.println(m.group(1));
        }
    }
}
```

Вопрос 34.  
Какой из способов сравнения строк предпочтительнее?  
str.equals("abc"); или "abc".equals(str);  
Поясните ответ.  
**Ответ.**   
`"abc".equals(str)` предпочтительнее так как в этом случае есть гарантированная строка "abc", что позволит избежать ошибки NullPointerException если str = null.

Вопрос 35.  
Как сравнить объекты StringBuilder и StringBuffer?  
**Ответ.**   
Для  классов  StringBuffer  и  StringBuilder  не  переопределены  методы equals() и hashCode(), т.е. сравнить содержимое двух объектов невозможно, следовательно, хэш-коды всех объектов этого типа вычисляются так же, как и для класса Object. При идентичном содержимом у двух экземпляров, размеры буфера каждого могут отличаться, поэтому сравнение на эквивалентность объектов представляется неоднозначным.  
Сравнить же содержимое можно следующим образом:  
sb1.toString().contentEquals(sb2);  
**Источник.** Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик, 2020. – 233-234с.

Вопрос 36.  
Что появится в консоли в результате работы фрагмента программы?  
```java
System.out.printf(
	"%d студентов пришли сдавать зачет по %8.10s, \n" 
	+ "из них не сдали %d, %s", 
	10, "J2SE", 5, "а остальные сдали на отлично"
);
```
Поясните ответ.  
**Ответ.**   
`10 студентов пришли сдавать зачет по     J2SE,`   
`из них не сдали 5, а остальные сдали на отлично`  
Исходя из аргументов метода `printf(String format, Object... args)` строки `"%d студентов пришли сдавать зачет по %8.10s, \n" + "из них не сдали %d, %s"` это `String format` который определяет 4-и последующих аргумента `Object... args`.  
`%d` определяет формат числа – аргумент 10  
`%8.10s` определяет формат строки в которой будет минимум 8 символов, но если их меньше то недостающие будут добавлены пробелами перед "J2SE", а 10 общее количество знаков в строке, и если их будет больше то строка будет обрезана до 10.  
`%d` определяет формат числа – аргумент 5  
`%s` определяет формат строки – "а остальные сдали на отлично"  

Вопрос 37.  
Сформировать регулярное выражение, при помощи которого можно выбрать все страницы, начинающиеся с "http" или "https" и заканчивающиеся на "by".  
**Ответ.** 
```java
String regexp = "http+s*://.+\\.by";
```

Вопрос 38.  
Сформировать регулярное выражение, при помощи которого можно выбрать все значения URL-запроса с ресурса https://bsut.by.
Например, запрос https://bsut.by?value1=5&value2=10&iscan=true.
Вывод
```
value1=5
value2=10
iscan=true
```
**Ответ.** 
```java
String regexp = "[ ?&]([^&]+)";
```

Вопрос 39.  
Базовые конструкции регулярных выражений, синтаксис (очень коротко, суть). Специальные символы, основные логические конструкции, предопределенные классы символов, логические операции, квантификаторы, группы.  
**Ответ.**   
При  создании  регулярного  выражения  могут  использоваться  логические операции:  
ab после а следует b  
a|b a или b  
Если необходимо, чтобы в строке, проверяемой на соответствие, в какой-либо позиции находился один из символов некоторого символьного набора, то такой набор (класс символов) можно объявить, используя одну из следующих конструкций:  
[abc] a или b или c  
[^abc] символ, исключая a, b и c  
[a-z] символ между a и z  
Кроме стандартных классов символов существуют предопределенные классы символов:  
. любой символ  
\d или \p{Digit} [0-9]  
\D [^0-9]  
\s или \p{Space} [ \t\n\x0B\f\r]  
\S [^\s]  
\w [0-9_A-Za-z]  
\W [^\w]  
Круглые скобки, кроме их логического назначения, также используются для определения групп.  
Для определения регулярных выражений недостаточно одних классов символов, т.к. в шаблоне часто нужно указать количество повторений. Для этого существуют квантификаторы.  
a? a один раз или ни разу  
a* a ноль или более раз  
a+ a один или более раз  
a{n} a n раз  
a{n,} a n или более раз  
a{n,m} a от n до m  
**Источник.** Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик, 2020. – 234-235с.

Вопрос 40.  
Назовите основные, на ваш взгляд, методы класса Pattern.  
**Ответ.**   
`static Pattern compile(String regex)` — возвращает Pattern, который соответствует regex;   
`static boolean matches(String regex, CharSequence input)` — проверяет на соответствие строки input шаблону regex;  
`String[]  split(CharSequence  input)`  —  разбивает  на  массив  строку  input, учитывая, что разделителем является шаблон;  
`Stream<String> splitAsStream(CharSequence input)` — разбивает в stream строку input, учитывая, что разделителем является шаблон;  
`Predicate<String> asPredicate()` — возвращает предикат на основе регулярного выражения;  
`Matcher matcher(CharSequence input)` — возвращает Matcher, с помощью которого можно находить соответствия в строке input.  
**Источник.** Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик, 2020. – 235с.

Вопрос 41.  
Назовите основные, на ваш взгляд, методы класса Matcher.  
**Ответ.**   
`String group()` — возвращает всю подпоследовательность, удовлетворяющую шаблону или нулевой группе;  
`String group(int group)` — возвращает конкретную группу по позиции;  
`int groupCount()` — определяет число групп сбора, представленных в сопоставляемом шаблоне. Всегда существует группа 0, представляющая все выражение и не включаемая в счетчик групп;  
`int start()` — возвращает индекс первого символа подпоследовательности, удовлетворяющей шаблону;  
`int start(int group) `— возвращает индекс первого символа указанной группы;  
`int end()` — возвращает индекс последнего символа подпоследовательности, удовлетворяющей шаблону;  
`int end(int group)` — возвращает индекс последнего символа указанной группы;   
`boolean hitEnd()` — возвращает истину, если был достигнут конец входной последовательности.  
**Источник.** Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик, 2020. – 238с.

Вопрос 42.  
Что появится в консоли в результате работы фрагмента программы?  
```java
System.out.println{"-1234".matches("-?\\d+"));
System. out. println ("5678". matches (" - ? \ \d+"));
System.out.println("+9ll".matches("-?\\d+"));
System.out.println("+911".matches("(-|\\+)?\\d+"));
```
Поясните ответ.  
**Ответ.**   
`true`
`"-1234".matches("-?\\d+")` –  
1) `-?` Строка может начинается со знака `-`, или же быть без него. В данном случае `–` есть.  
2) `\\d+` - от 1 и более цифр, в данном случае 4 цифры.  
`true`  
`"5678". matches (" - ? \ \d+")` - выражение аналогично предыдущему только строка начинается без `-`, т.е. в обоих случаях будет `true`.
`false`
`"+9ll".matches("-?\\d+") `- регулярное выражение аналогично первым двум, только в этот раз строка начинается с недопустимого символа +, поэтому будет `false`.  
`true`  
`"+911".matches("(-|\\+)?\\d+")` – согласно регулярному выражению `(-|\\+)? `строка может начинаться как со знака `–` так и со знака `+`, или вообще не иметь знака. После этого согласно `\\d+` может идти любое количество цифр.  

Вопрос 43.  
Что появится в консоли в результате работы фрагмента программы? 
```java
System.out.println(Arrays.toString("Then, when you have found the gold.".split("n\\W+")));
```
Поясните ответ.  
**Ответ.** 
```
[The, whe, you have found the gold.]
```
Строка разбивается методом `split()` на массив в тех местах где присутствуют идущие подряд буква `n` и любое количество символов не входящих в диапазон `[a-zA-Z0-9]`.

Вопрос 44.  
Сформируйте и протестируйте регулярное выражение, которое проверяет, что предложение начинается с прописной буквы и завершается точкой.  
**Ответ.**
```java
String regexp = "\\p{Lu}.+\\.$”;
```
Примечание выражение `\p{Lu}` в зависимости от языка программирования может иметь другое написание. Знак `$` используется для указания конца строки, на случай если в здании предполагалось проверить полное соответствие строки условию, а не вхождение.

Вопрос 45.   
Сформируйте и протестируйте регулярное выражение, которое заменяет все гласные подчеркиваниями в предложении "Then, when you have found the gold".  
**Ответ.**  
Само регулярное выражение не может производить манипуляции со строкой, поэтому необходимо воспользоваться методами в JAVA использующими регулярные выражения для поиска и замены. Например для строк это .replaceAll(). В этом случае итоговая запись будет следующая.
```java
String result = "Then, when you have found the gold".replaceAll("[aeiouyAEIOUY]", "_");
```

Вопрос 46.  
Определите, будет ли найдено в строке "Java now has regular expressions" совпадение для следующих выражений:
```
^Java
\Breg.*
n.w\s+h(a|i)s
s?
s*
s+
S{4}
S{1}
S{0,3}
```
Поясните ответ.  
**Ответ.**   
`^Java` – найдено, строка начинается с Java  
`\Breg.*` - слово не должно начинаться с reg, но должно быть в средине слова или в конце, так что совпадений нет.  
`n.w\s+h(a|i)s` – совпадение Match на подстроке “now has ” и одно вхождение “а” в Group 1.  
`s?` - совпадение Match будет происходить на каждом символе, т.к. “?” подразумевает “ноль или 1 символ”  
`s*` - совпадение Match будет происходить на каждом символе, т.к. “*” подразумевает “ноль или больше символов”  
`s+` - будет 3-и совпадения Match, каждый раз когда встречается “s”, т.к. “+” подразумевает одно и более раз.  
`S{4}` - в исходной стране нет случая когда встречается SSSS.  
`S{1}` - в исходной стране нет случая когда встречается S.  
`S{0,3}` - - совпадение Match будет происходить на каждом символе, т.к. {0,3}  подразумевает “от ноля до 3 раз”.  

Вопрос 47.  
Примените регулярное выражение  
```
(?i)((^[aeiou])|(\s+[aeiou]))\w+?[aeiou]\b
```
к строке
```
"Arline ate eight apples and one orange while Anita hadn't any"
```
Поясните ответ.  
**Ответ.**  
5 совпадений  Match на “Arline” “ ate” “ one” “ orange” “ Anita”   
5 совпадения Group 1 ((^[aeiou])|(\s+[aeiou]))  “А” “ а” “ о” “ о” “ А”  
1 совпадение Group 2 (^[aeiou])  “А”  
4 совпадения Group 3 (\s+[aeiou]) “ а” “ о” “ о” “ А”  

Вопрос 48.  
Какие подстроки извлекают следующие регулярные выражения?
```
[0-6]
[^n-p]
[A-Za-z0-9_]
\w
[A-C][n-p][a-c]
waz{3,5}up
[abc]+
.*
```
**Ответ.**   
`[0-6]` - любой одинарный символ от 0 до 6. При следовании подряд каждый символ из диапазона будет восприниматься как отдельное совпадение.  
`[^n-p]` – любой символ как отдельное совпадение кроме символов из диапозона n-p.  
`[A-Za-z0-9_]` – всё буквы английского алфавита в большом и маленьком регистре, все цифры и дополнительно символ “_”.  
`\w` – совпадение на любой букве или цифре.  
`[A-C][n-p][a-c]` – совпадения на трех символах, причем первый символ входит в диапазон A-C, второй символ в диапазон n-p, а третий соответственно в a-c. Например Арс.    
`waz{3,5}up` – совпадение на слове начинающемся с wa затем символ z  от 3 до 5 раз и конец слова up. Например wazzzup.  
`[abc]+` - совпадение на любой из символов abc встречающихся 1 и более раз.  
`.*` - два Match совпадения на любой не пустой строке, первое это вся строка, второй случай сама пустая строка.  

Вопрос 49.  
Сформируйте регулярное выражение, которое находит предложения, начинающиеся с "Input:" и заканчивающиеся на "successful".  
**Ответ.**   
```java
String regexp = "Input:.*?successful$";
```
Примечание. Знак `$` используется для указания конца строки, на случай если в здании предполагалось проверить полное соответствие строки условию, а не вхождение.

Вопрос 50  
Сформируйте регулярное выражение, которое выделяет в обрабатываемом тексте названия файлов (имя + расширение) графических форматов gif, png, jpg.  
**Ответ.** 
```java
String regexp = "\\w+\\.(jpg|gif|png)";
```
