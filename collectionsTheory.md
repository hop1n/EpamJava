1. Дайте неформальное определение контейнера.  
**Ответ.**  Контейнерами в Java принято называть классы, основная цель которых – хранить набор других элементов.  
**Источник.** https://javarush.ru/quests/lectures/questsyntax.level08.lecture01  
 

2. Дайте определение коллекции в java.  
**Ответ.**  Коллекция - иногда называемая контейнером - это просто объект, который группирует несколько элементов в единое целое. Коллекции используются для хранения, извлечения, обработки и передачи агрегированных данных.  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/intro/index.html  
 

3. Какой имеется в java контейнер, отличный от коллекций? Дайте ему определение.  
**Ответ.** Массив - это объект-контейнер, который содержит фиксированное количество значений одного типа.  
**Источник.** https://docs.oracle.com/javase/7/docs/api/java/util/Collection.html 
 

4. Дайте определение Collections framework?  
**Ответ.** Фреймворк коллекций - это унифицированная архитектура для представления коллекций и управления ими.  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/intro/index.html 
 

5. Какие разделы содержит Collections framework? Определите их, и для чего они предназначены?  
**Ответ.** 
- Interfaces: это абстрактные типы данных, представляющие коллекции. Интерфейсы позволяют манипулировать коллекциями независимо от деталей их представления. В объектно-ориентированных языках интерфейсы обычно образуют иерархию.  
- Implementations: это конкретные реализации интерфейсов коллекций. По сути, это многократно используемые структуры данных.  
- Algorithms: это методы, которые выполняют полезные вычисления, такие как поиск и сортировка, на объектах, реализующих интерфейсы коллекций. Алгоритмы называются полиморфными: то есть один и тот же метод может использоваться во многих различных реализациях соответствующего интерфейса коллекции. По сути, алгоритмы - это многоразовые функции.  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/intro/index.html
 

6. В чем преимущества использования Collections Framework?  
**Ответ.** 
- Снижает усилия по программированию: предоставляя полезные структуры данных и алгоритмы. Облегчая взаимодействие между несвязанными API-интерфейсами, Java Collections Framework освобождает вас от написания объектов-адаптеров или кода преобразования для подключения API-интерфейсов.  
- Повышает скорость и качество программы: эта платформа коллекций обеспечивает высокопроизводительные и высококачественные реализации полезных структур данных и алгоритмов. Различные реализации каждого интерфейса взаимозаменяемы, поэтому программы можно легко настраивать, переключая реализации коллекций.  
 - Обеспечивает взаимодействие между несвязанными API-интерфейсами: интерфейсы коллекций - это разговорный язык, с помощью которого API-интерфейсы передают коллекции туда и обратно.  
- Снижает усилия по изучению и использованию новых API-интерфейсов: многие API-интерфейсы, естественно, принимают коллекции на вход и предоставляют их в качестве выходных данных.  
- Снижает усилия по разработке новых API - вместо этого можно использовать стандартные интерфейсы сбора.
- Способствует повторному использованию программного обеспечения: новые структуры данных, соответствующие стандартным интерфейсам сбора данных, по своей природе допускают повторное использование.  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/intro/index.html  
 

7. Является ли антипаттерном следующее объявление ссылки на коллекцию?  
Collection collection;  
Если да, то как называется антипаттерн и исправьте объявление ссылки.  
**Ответ.** Является.  
Когда вы объявляете экземпляр Collection, вы можете и должны указать тип объекта, содержащегося в коллекции. Указание типа позволяет компилятору проверять (во время компиляции), что тип объекта, который вы помещаете в коллекцию, правильный, тем самым уменьшая количество ошибок во время выполнения. `Collection<E> collection`.  
**Источник.** Джошуа Блох. Java Эффективное программирование. 3 издание. 2019. стр. 164  
???
Вы можете поместить любой элемент в коллекцию с несформированным типом и при этом легко нарушить инварианты типа коллекции, но вы не можете поместить любой элемент (кроме null) в коллекцию `Collection<?> collection`. Такая попытка приведет к сообщению об ошибке времени компиляции: `Wildcard.java:13: error: incompatible types`  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/index.html  
 

8. К каким негативным последствиям может привести использование raw types? Приведите пример.  
**Ответ.**  
Используя несформированные типы, теряются все преимущества безопасности и выразительности обобщенного программирования. 
```java
// Коллекция марок. Содержит только экземпляры Stamp. 
private final Collection stamps = ... ;
stamps.add(new Coin( ... )); // Предупреждение "непроверенный вызов"
for (Iterator i = stamps.iterator(); i.hasNext();)
Stamp stamp = (Stamp) i.nextO; // Генерация ClassCastException 
```
Если использовать это объявление, а затем случайно добавите в коллекцию марок монету, такая ошибочная вставка скомпилируется и выполнится без ошибок (хотя компилятор выдаст расплывчатое предупреждение). Вы не получите сообщение об ошибке до тех пор, пока не попытаетесь получить(например итератором) монету из коллекции марок. Ошибка не обнаружится до момента выполнения программы, гораздо позже, чем она была допущена, и совершенно не в том коде, в котором она была допущена. Когда вы увидите исключение ClassCastException, вам придется просматривать весь код и искать вызов метода, который помещает монету в коллекцию марок.  
**Источник.**  Джошуа Блох. Java Эффективное программирование. 3 издание. 2019. стр. 160  

**Ответ.** Так как в коллекциях при практическом программировании хранится набор ссылок на объекты одного типа, следует обезопасить коллекцию от появления ссылок на другие, не разрешенные логикой приложения типы. Такие ошибки при использовании нетипизированных коллекций выявляются на стадии выполнения, что повышает трудозатраты на исправление и верификацию кода. Поэтому, начиная с версии Java SE 5, коллекции стали типизированными или generic.
**Источник.** Java from EPAM: учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик, 2020. – 320 с.

 
9. Почему допускаются raw types с коллекциями?  
**Ответ.** Поддержка raw types остается для обратной совместимости.  
Есть всего три случая, когда использовать обобщенный тип без параметра правильно:
- Целевая версия Java < 5.0 (migration compatibility);
- В литерале класса. `List<String>.class` не сработает, нужно писать `List.class`;
- В операторе `instanceof`. Вместо `instanceof Set<Integer>` должно быть `instanceof Set`.  
**Источник.** https://itsobes.ru/JavaSobes/kogda-nuzhno-ispolzovat-raw-types/
 

10. Какое главное назначение раздела Интерфейсы?  
Другими словами, если известен интерфейс коллекции, то что это дает программисту?  
**Ответ.** Интерфейсы позволяют манипулировать коллекциями независимо от деталей их представления.  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/index.html  
 

11. Какое главное назначение раздела Имплементации?  
Другими словами, если известна имплементация, то что это дает программисту?  
**Ответ.** Имплементация обязует реализовать все методы указанного интерфейса.  
**Источник.**  

 
12. Приведите иерархию интерфейсов коллекций.  
**Ответ.** На вершине иерархии в Java Collection Framework располагаются 2 интерфейса: Collection и Map.  
Эти интерфейсы разделяют все коллекции, входящие во фреймворк на две части по типу хранения данных: простые последовательные наборы элементов и наборы пар «ключ — значение» (словари).  
Интерфейс Collection включает в себя интерфейсы List, Set(SortedSet, NavigableSet), Queue(Deque).  
Интерфейс Map включает в себя интерфейсы SortedMap и NavigableMap.    
**Источник.** https://habr.com/ru/post/237043/ 
 

13. Какие существуют способы прохода (traversing) по коллекции до версии java 8 (т.е. от версии 5 до версии 7 включительно)?   
Приведите идиомы для следующей коллекции:  
Collection<Entity> entities = …;  
Какой способ является более подходящим для прохода по коллекции до версии java 8?  
**Ответ.**  Классический цикл for, в котором переменная счетчика выполняется от первого элемента до последнего в коллекции. 
```java 
for (int i = 0; i < entities.size(); i++) {
    System.out.println(entities.get(i));
}
```
С помощью метода iterator() и цикла while
```java 
Iterator<Entity> iterator = entities.iterator();
while (iterator.hasNext()) {
    System.out.println(iterator.next());
}
```
Наиболее подходящий способ для прохода по коллекции, начиная с Java 5, это улучшенный цикл for. 
```java
for (Entity e : entitie) {
    System.out.println(e);
}
```
**Источник.**  https://www.codejava.net/java-core/collections/the-4-methods-for-iterating-collections-in-java
 

14. Реализация какого интерфейса позволяет коллекциям использоваться в конструкции for-each?  
Какой метод этого интерфейса обеспечивает данную возможность?  
**Ответ.** Реализация интерфейса Iterable и его метода iterator() использоваться в конструкции for-each.  
**Источник.** https://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html
 

15. Что такое итератор?  
**Ответ.** Итератор в Java является объектом, реализующим интерфейс Iterator или ListIterator. Итератор позволяет циклически проходить через коллекцию, получать или удалять элементы. ListIterator расширяет Iterator, чтобы разрешить двунаправленный обход списка и модификацию элементов.  
**Источник.** https://hr-vector.com/java/iterator 
 

16. Дана коллекция из n элементов. Сколько в ней существует возможных позиций курсора итератора?  
**Ответ.**  В коллеции длинной n имеется n+1 действительных значений(позиций курсора) для индекса, от 0 до n включительно.  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/list.html   
 

17. Какие методы объявлены в интерфейсе Iterator<E>? Охарактеризуйте их.  
**Ответ.**  
`boolean hasNext()	` проверяет, есть ли в коллекции следующий элемент. Если есть, то метод возвращает true, если нет – false.  
`Object next()` возвращает следующий элемент коллекции. Если элемент не обнаружен, то метод “бросает” NoSuchElementException.  
`void remove()` удаляет текущий элемент. Важный момент заключается в том, что сначала этот элемент необходимо получить с помощью метода next(), если мы вызовем метод remove() до метода next(), то мы получим IllegalStateException.  
**Источник.** https://proselyte.net/tutorials/java-core/collections-framework/iterator/
 

18. В каких случаях следует явно использовать итератор вместо for-each?  
**Ответ.**  Если нам нужно изменить коллекцию(удалить элемента или изменить содержимое элемента, хранящегося в коллекции), нужно использовать Iterator.  
В цикле for-each мы не можем изменять коллекцию, иначе будет выброшено исключение ConcurrentModificationException.  
**Источник.** https://www.geeksforgeeks.org/iterator-vs-foreach-in-java/ 
 

19. Пусть условие удаления элемента из коллекции Collection<Entity> entities задается методом isRemoved() класса Entity. 
Приведите идиому удаления элементов этой коллекции.  
**Ответ.** 
```java
Collection<Entity> entities;
for (Iterator iterator = entities.iterator(); iterator.hasNext();) {
    Entity entity = (Entity) iterator.next();
    if (entity.isRemoved() ) {
        iterator.remove();
    }
}
``` 
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/collection.html 
 

20. Какие группы методов (или операций) объявлены в интерфейсе Collection (до java 8)?  
Какие методы входят в каждую группу?  
**Ответ.**  
«Деструктивные» методы - методы (optional operation), которые изменяют коллекцию, с которой они работают, задаются для создания исключения UnsupportedOperationException, если эта коллекция не поддерживает операцию. В этом случае эти методы могут, но не обязаны, генерировать исключение UnsupportedOperationException, если вызов не повлияет на коллекцию. Например, вызов метода addAll (Collection) для неизменяемой коллекции может, но не обязательно, вызывать исключение, если добавляемая коллекция пуста.  
```java
boolean add(E e) // optional operation
boolean addAll(Collection<? extends E> c) // optional operation
void clear() //optional operation
boolean contains(Object o)
boolean containsAll(Collection<?> c)
boolean equals(Object o)
int hashCode()
boolean isEmpty()
Iterator<E> iterator()
boolean remove(Object o) // optional operation
boolean removeAll(Collection<?> c) // optional operation
boolean retainAll(Collection<?> c) // optional operation
int size()
Object[] toArray()
<T> T[] toArray(T[] a)
```
**Источник.** https://docs.oracle.com/javase/7/docs/api/java/util/Collection.html  
 

21. В чем разница методов Object[] toArray(), <T> T[] toArray(T[] a) интерфейса Collection?  
**Ответ.**  
Object[] toArray() — копирует элементы коллекции в массив объектов;  
<T> T[] toArray(T a[]) — копирует элементы коллекции в массив объектов определенного типа.  
**Источник.**  Блинов, Романчик. Java from EPAM. 2020. стр 322  
Подобно методу Object[] toArray(), метод <T> T[] toArray(T[] a) действует как мост между API на основе массивов и на основе коллекций. Кроме того, этот метод позволяет точно контролировать тип среды выполнения выходного массива и может, при определенных обстоятельствах, использоваться для экономии затрат на выделение ресурсов.  
**Источник.** https://docs.oracle.com/javase/7/docs/api/java/util/Collection.html
 

22. В описании методов интерфейсов коллекций в JavaDoc есть методы, помеченные фразой “optional operation”:  
boolean add(E e) - Ensures that this collection contains the specified element (optional operation).  
boolean addAll(Collection<? extends E> c)  - Adds all of the elements in the specified collection to this collection (optional operation).  
void clear() - Removes all of the elements from this collection (optional operation).  
Как это понимать?  
**Ответ.** То, что метод интерфейса указан как optional operation в JavaDoc, означает, что классы, реализующие этот интерфейс, не обязательно должны реализовывать этот метод.  
Методы оставшиеся нереализованными, при их вызове, могут вызывать исключения UnsupportedOperationException.  
Причина, по которой операция может быть объявлена необязательной, заключается в том, что некоторые наборы могут быть концептуально неизменяемыми, например те, которые возвращаются Collections.unmodifiableSet.  
**Источник.** https://coderoad.ru/8375653/Что-означает-optional-operation-в-Javadoc-например-Set-add-E  
https://coderoad.ru/10572643/Дополнительные-методы-в-интерфейсе-Java   

23. Какую математическую сущность моделирует интерфейс Set?  
**Ответ.** Как следует из его названия, этот интерфейс моделирует абстракцию математического множества.  
**Источник.** java.util.Set  
Этот интерфейс моделирует абстракцию математического набора и используется для представления наборов.  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/index.html 
 

24. Какое основное свойство всех имплементаций интерфейса Set, т.е. что их объединяет независимо от имплементации?  
**Ответ.** Интерфейс Set не допускает дублирования элементов.   
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/summary.html
 

25. Может ли множество содержать null элемент?  
**Ответ.** Может, но не более одного null элемента.  
**Источник.** java.util.Set
 

26. Есть ли отношение следования (предыдущий, текущий, следующий элемент) в множестве?  
Если нет, то есть ли у множества итератор?  
**Ответ.** Метод java.util.Set.iterator() используется для возврата итератора тех же элементов, что и набор. Элементы возвращаются в случайном порядке из того, что присутствует в наборе.  
**Источник.** https://www.geeksforgeeks.org/set-iterator-method-in-java-with-examples/  
 

27. Как получить элемент множества по индексу?  
**Ответ.**  
```java
Set<String> set = new HashSet<String>();

// Преобразовать множество в ArrayList 
List<String> list = new ArrayList<String>(set);
System.out.println(list.get(3));

// Преобразование множество в массив с помощью метода toArray() 
String[] array = set.toArray(new String[set.size()]);
System.out.println(array[3]);

// Использовать цикл
int currentIndex = 0;
int desiredIndex = 3;
for (String element : set) { 
    if (currentIndex == desiredIndex) {
        System.out.println("Element at index 3 is: " + element);
        break;
    }
    currentIndex++;
}
```
**Источник.** https://www.geeksforgeeks.org/how-to-get-elements-by-index-from-hashset-in-java/ 
 

28. Как реализован метод add() во множестве?  
**Ответ.** `boolean add(E e);
Добавляет указанный элемент в множество, если он еще не присутствует (необязательная операция).  
Более формально, добавляет указанный элемент e в множество, если множество не содержит такого элемента e2 `(e == null? E2 == null: e.equals (e2))`. Если множество уже содержит элемент, вызов оставляет множество без изменений и возвращает false. В сочетании с ограничением на конструкторы это гарантирует, что множества никогда не содержат повторяющихся элементов.  
Вышеупомянутое условие не подразумевает, что множества должны принимать все элементы; set может отказаться от добавления любого конкретного элемента, включая null, и вызвать исключение, как описано в спецификации Collection.add. Реализации отдельных наборов должны четко документировать любые ограничения на элементы, которые они могут содержать. 
**Источник.** java.util.Set 
 

29. Какая группа методов увеличилась в интерфейсе Set по сравнению с интерфейсом Collection?  
Какие методы добавились?  
**Ответ.** Добавили `void clear();`  
**Источник.** java.util.Set   
 

30. Зависит ли множество, как структура данных, от имплементации? Обоснуйте ответ.  
**Ответ.** Зависит, т.к. разные реализации имеют разные способы хранения коллекции.  
**Источник** https://docs.oracle.com/javase/tutorial/collections/interfaces/set.html
 

31. Какие методы должны быть переопределены в классе, которым параметризовано множество, чтобы гарантировать правильную работу HashSet имплементации?  
**Ответ.** Для грамотной организации HashSet следует следить, чтобы реализации методов hashCode() и equals() соответствовали контракту.  
**Источник.** Блинов И. Н., Романчик В. С. - Java from EPAM: учеб.-метод. пособие 2013, стр. 271  
 

32. Какие соглашения установлены для переопределения метода hashCode()?  
**Ответ.** Общий контракт hashCode:  
- Каждый раз, когда hashCode() вызывается для одного и того же объекта более одного раза, метод должен последовательно возвращать одно и то же целое число, при условии, что никакая информация, используемая в равных сравнениях для объекта, не изменяется. Это целое число не обязательно должно оставаться согласованным от одного выполнения приложения к другому выполнению того же самого приложения.  
- Если два объекта равны в соответствии с методом equals(), то вызов метода hashCode для каждого из двух объектов должен привести к одинаковому целочисленному результату.  
- Если два объекта не равны в соответствии с методом equals(), тогда вызов метода hashCode для каждого из двух объектов должен давать различные целочисленные результаты. Однако программист должен знать, что получение различных целочисленных результатов для неравных объектов может улучшить производительность хэш-таблиц.  
**Источник.** https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html
 

33. Почему недостаточно переопределить один только метод hashCode()?  
**Ответ.** Вы должны переопределить hashCode() в каждом классе, который переопределяет equals(). Несоблюдение этого требования приведет к нарушению общего договора для Object.hashCode(), что предотвратит правильное функционирование вашего класса в сочетании со всеми коллекциями на основе хешей, включая HashMap, HashSet и Hashtable.  
**Источник.** https://overcoder.net/q/22728/%D0%BF%D0%BE%D1%87%D0%B5%D0%BC%D1%83-%D0%BC%D0%BD%D0%B5-%D0%BD%D1%83%D0%B6%D0%BD%D0%BE-%D0%BF%D0%B5%D1%80%D0%B5%D0%BE%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B8%D1%82%D1%8C-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D1%8B-equals-%D0%B8-hashcode-%D0%B2-java


34. Являются ли приведенная реализация hashCode() допустимой (в смысле будут ли правильно выполняться все операции над множеством)?  
```java
@Override 
public int hashCode() {
    return 22;
}
```
**Ответ.** Данная реализация допустима но является самой плохой из возможных. Такая реализация повлияет на поиск элементов в HashSet. Т.к. потеряется смысл HashSet как структуры данных, потому что значения будут сохраняться в связанный список.  
**Источник.** https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html  

не допускается
т.к. "В теории хэширования существует такое понятие как коллизия – это явление, когда для разных объектов получается одинаковый хэш-код." (с) 
т.к. сет хранит уникальные элементы, то может возникнуть ситуация, когда при добавлении объекта он будет проверен как существующий, и соотвественно не будет добавлен в set..
https://ru.stackoverflow.com/questions/619860/%D0%97%D0%B0%D0%B2%D0%B8%D1%81%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D1%8C-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%8B-hashset-%D0%BE%D1%82-%D0%BF%D0%B5%D1%80%D0%B5%D0%BE%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F-equals-%D0%B8-hashcode-%D1%83-%D1%8D%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82%D0%BE%D0%B2


**Вопрос 35.** Являются ли приведенная реализация hashCode() допустимой (в смысле будут ли правильно выполняться все операции над множеством HashSet<Entity>)?
```java 
class Entity {
private int value;
public int getValue() {
return value;
}
public void setValue(int value) {
this.value = value;
}
@Override
public boolean equals(Object obj) {
if (this == obj) return true;
if (obj == null || getClass() != obj.getClass()) return false;
Entity entity = (Entity) obj;
return value == entity.value;
}
@Override
public int hashCode() {
int result = 1;
result = result * 31 + value;
return result;
}
}
```
**Ответ.** Данная реализация является недопустимой. В HashSet объект по факту является ключем HashMap.  
Если у любого объекта, который выступает в качестве ключа, изменить поле, которое участвует в вычислении хеш-кода - то при попытке найти данный элемент по исходному ключу, будет происходить обращение к правильной корзине, а вот equals (ведь equals и hashCode должны работать с одним и тем же набором полей) уже не найдет указанный ключ в списке элементов. Тем не менее, даже если equals реализован таким образом, что изменение данного поля объекта не влияет на результат, то после увеличения размера корзин и пересчета хеш-кодов элементов, указанный элемент, с измененным значением поля, с большой долей вероятности попадет совсем в другую корзину и тогда он уже совсем потеряется.  
**Источник** https://habr.com/ru/post/162017/  

Данная реализация является недопустимой.  
HashSet определяет, в какую корзину положить объект, по значению hashCode(). Если объект, лежащий в HashSet, со временем станет возвращать другое значение hashCode(), методы add, contains и прочие будут работать некорректно. Самое простое и правильное решение - использовать неизменяемые объекты.  
https://javanese.online/%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D1%8B_JVM-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/%D1%81%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D0%BD%D0%B0%D1%8F_%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B0_Java/hashCode_equals/


**Вопрос 36.** Какие методы должны быть переопределены в классе, которым параметризовано множество, чтобы гарантировать правильную работу TreeSet имплементации?  
**Ответ.** compareTo().  
**Источник.** https://docs.oracle.com/javase/7/docs/api/java/util/TreeSet.html  
  
Экземпляр TreeSet выполняет все сравнения элементов, используя свой метод compareTo (или compare), поэтому два элементы, которые считаются равными с помощью этого метода, равны с точки зрения множества. Поведение набора четко определено, даже если его порядок несовместим с equals; он просто не подчиняется общему соглашению интерфейса Set.  
**Источник.** https://docs.oracle.com/javase/7/docs/api/java/util/TreeSet.html  


**Вопрос 37.** В чем заключается актуальность внешнего компаратора?  
**Ответ.** 
Если поле не реализует интерфейс Comparable или вам необходимо нестандартное упорядочение, используйте вместо него Comparator.  
**Источник.** Блох 103-104с.  
 
**Ответ.** В собственном компараторе можно применить необходимую последовательность полей объектов для сравнения.
Компараторы можно передать методу сортировки (например, Collections.sort или Arrays.sort), чтобы обеспечить точный контроль над порядком сортировки. Компараторы также могут использоваться для управления порядком определенных структур данных (таких как отсортированные наборы или отсортированные карты) или для обеспечения упорядочения коллекций объектов, которые не имеют естественного порядка.  
**Источник.** https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html


**Вопрос38.** Дана следующая коллекция:  
Collection<Entity> entities = …;  
Приведите идиому, позволяющую оставить только уникальные элементы в коллекции при условии правильной реализации класса Entity.  
**Ответ.** `Collection<Entity> collection = new HashSet<Entity>(entities);`  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/set.html


**Вопрос 39.** Какую математическую сущность моделирует интерфейс List?  
**Ответ.** List - это упорядоченный Collection(иногда называемый sequence). Списки могут содержать повторяющиеся элементы.  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/list.html


**Вопрос 40.** Какое основное свойство всех имплементаций интерфейса List, т.е. что их объединяет независимо от имплементации?  
**Ответ.** Порядок хранения элементов не меняется при добавлении или удалении элементов, доступ к элементам списка осуществляется по индексу.  

**Вопрос 41.** Может ли имплементация интерфейса List содержать одинаковые элементы? Обоснуйте ответ.  
**Ответ.** Могут, хотя некоторые реализации содержать ограничения.  
**Источник.**  http://www.seostella.com/ru/article/2012/08/08/kollekcii-collections-v-java-list.html  

**Вопрос 42.** Какие группы методов увеличились в интерфейсе List по сравнению с интерфейсом Collection?
Какие методы добавились?  
**Ответ.** List добавляет следующие методы:  
`void add(int index, Е obj)` вставляет obj в вызывающий список в позицию, указанную в index. Любые ранее вставленные элементы за указанной позицией вставки смещаются вверх. То есть никакие элементы не перезаписываются.  
`bооlеаn addAll (int index,Collection<? extends Е> с)` вставляет все элементы в вызывающий список, начиная с позиции, переданной в index. Все ранее существовавшие элементы за точкой вставки смещаются вверх. То есть никакие элементы не перезаписываются. Возвращает true, если вызывающий список изменяется, и false в противном случае.  
`Е get (int index)` возвращает объект, сохраненный в указанной позиции вызывающего списка.  
`int indexOf(Object obj)` возвращает индекс первого экземпляра obj в вызывающем списке. Если obj не содержится в списке, возвращается 1.  
`int lastlndexOf(Object obj)` возвращает индекс последнего экземпляра obj в вызывающем списке. Если obj не содержится в списке, возвращается 1.  
`Listlterator listlterator()` возвращает итератор, указывающий на начало списка.  
`Listlterator listlterator(int index)` возвращает итератор, указывающий на заданную позицию в списке.  
`Е remove(int index)` удаляет элемент из вызывающего списка в позиции index и возвращает удаленный элемент. Результирующий список уплотняется, то есть элементы, следующие за удаленным, сдвигаются на одну позицию назад.  
`Е set (int index, Е obj)` присваивает obj элементу, находящемуся в списке в позиции index.  
`default void sort(Comparator<? super E> c)` сортирует список, используя заданный компаратор (добавлен в версии JDK 8).  
`List subList (int start, int end)` возвращает список, включающий элементы от start до end-1 из вызывающего списка. Элементы из возвращаемого списка также сохраняют ссылки в вызывающем списке.  
**Источник.** https://www.examclouds.com/ru/java/java-core-russian/interface-list


**Вопрос 43.** Влияют ли изменения внесенные в последовательность, возвращаемый методом subList(), на исходную последовательность?  
**Ответ.** Да, так как он не возвращает новый список, а вид(view) исходного.  
**Источник.** https://habr.com/ru/post/133357/  
 
**Ответ.** Влияют. Возвращаемый список поддерживается исходным списком, поэтому неструктурные изменения в возвращаемом списке отражаются в исходном списке, и наоборот. Возвращенный список поддерживает все дополнительные операции со списком, поддерживаемые этим списком.  
**Источник.** https://docs.oracle.com/javase/8/docs/api/java/util/List.html#subList-int-int-


**Вопрос 44.** Дана следующая последовательность: List<Entity> entities = …;
Приведите идиому, позволяющую удалить все элементы с номерами из полусегмента (fromIndex; toIndex).  
**Ответ.** `entities.subList(fromIndex; toIndex).clear();`
```java
        List<Integer> theNumbers = Arrays.asList(1, 2, 3, 4, 5);
        theNumbers.subList(0, 3).clear();
        System.out.println(theNumbers); // java.lang.UnsupportedOperationException
```
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/list.html


**Вопрос 45.** Дана следующая неупорядоченная последовательность и некоторый элемент для сравнения:
List<Entity> entities = …;
Entity cmpEntity = …;
Приведите идиому для выполнения метода void doAction() класса Entity со всеми элементами последовательности entities, которые совпадают с элементом cmpEntity.
Запрещается упорядочивать последовательность и явно проверять на равенство каждый элемент последовательности.  
**Ответ.**
```java
List<Entity> entities;
Entity cmpEntity ;
do{
    int index = entities.indexOf(cmpEntity);
    if(index >= 0){
        entities.get(index).doAction();
        entities.remove(index);
        }
        }while(entities.indexOf(cmpEntity)>=0)
```
**Источник.** https://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html  

46. Какую математическую сущность моделирует интерфейс Queue?  
**Ответ.** Queue (очередь) - коллекция, предназначенная для хранения элементов перед обработкой. Интерфейс Queue позволяет дополнительные операции вставки, извлечения и проверки. Элементы в Queue обычно упорядочиваются по принципу FIFO.  
**Источник.** https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Queue.html  
https://docs.oracle.com/javase/tutorial/collections/interfaces/summary.html


47. Какое основное свойство всех имплементаций интерфейса Queue, т.е. что их объединяет независимо от имплементации?  
**Ответ.** Каждая имплементация интерфейса Queue должна указывать свои свойства упорядочивания элементов в очереди, при этом элементы добавляются в один конец списка, а извлекаются из другого конца.  
**Источник.** https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Queue.html   
Блинов И. Н., Романчик В. С. - Java from EPAM: учеб.-метод. пособие 2020, стр. 321
 

48. Какие группы методов увеличились в интерфейсе Queue по сравнению с интерфейсом Collection?  
Какие методы добавились?  
**Ответ.** Помимо основных операций интерфейса Collection, очереди предоставляют дополнительные операции вставки, извлечения и проверки. Каждый из этих методов существует в двух формах: один выдает исключение в случае сбоя операции, другой возвращает специальное значение (либо null или false, в зависимости от операции). Последняя форма операции вставки разработана специально для использования с Queue реализациями с ограниченной пропускной способностью; в большинстве реализаций операции вставки не могут завершиться ошибкой.  
Методы интерфейса Queue:  
`boolean add(E o)` вставляет элемент в очередь, но если же очередь полностью заполнена, то генерирует исключение IllegalStateException;  
`boolean offer(E o)` вставляет элемент в очередь, если возможно;  
`E element()` возвращает, но не удаляет головной элемент очереди;  
`E peek()` возвращает, но не удаляет головной элемент очереди, возвращает null, если очередь пуста;  
`E poll()` возвращает и удаляет головной элемент очереди, возвращает null, если очередь пуста;  
`E remove()` возвращает и удаляет головной элемент очереди.  
Методы, специфичные для Queue, предоставляют полную и законченную функциональность. Иначе говоря, можно получить работоспособную очередь без использования методов интерфейса Collection, от которого наследует Queue.  
**Источник.** https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Queue.html  
Блинов И. Н., Романчик В. С. - Java from EPAM: учеб.-метод. пособие 2020, стр. 342
 

49. Какую математическую сущность моделирует интерфейс Deque?  
**Ответ.** Этот интерфейс расширяет интерфейс Queue, определяет методы доступа к элементам на обоих концах двухсторонней очереди. Когда двухсторонняя очередь используется в качестве очереди, возникает поведение FIFO (First-In-First-Out). Элементы добавляются в конец двухсторонней очереди и извлекаются с начала.  
Deques также можно использовать в качестве стеков LIFO (Last-In-First-Out). Когда двухсторонняя очередь используется в качестве стека, элементы добавляются и извлекаются с начала двухсторонней очереди.  
**Источник.** https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Deque.html
 

50. Какое основное свойство всех имплементаций интерфейса Deque, т.е. что их объединяет независимо от имплементации?  
**Ответ.** Наличие возможности добавления и удаления элементов с обоих концов очереди.  
**Источник.** https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Deque.html
 

51. Какие методы определяет Deque в добавок к методам унаследованным от Queue?  
**Ответ.** addFirst(e), offerFirst(e), removeLast(), getLast(), pollLast(), peekLast()  
**Источник.** https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Deque.html
 

52. Верно ли утверждение, что Queue всегда обрабатывает элемента в порядке FIFO?  
**Ответ.** Нет. Очереди обычно, но не обязательно, упорядочивают элементы по принципу FIFO (first-in-first-out). Среди исключений - очереди с приоритетом, которые упорядочивают элементы в соответствии с предоставленным компаратором или естественным порядком элементов, и очереди LIFO (или стеки), которые упорядочивают элементы LIFO (последним вошел - первым вышел).  
**Источник.** https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Queue.html
 

53. Какой элемент независимо от упорядочения Queue будет удален методами remove и poll?  
**Ответ.** Заголовок очереди (the head of the queue) – это элемент в начале очереди, который будет удален при вызове remove или poll.  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/queue.html


54. Зачем в интерфейсе Queue метод poll, когда есть remove?  
**Ответ.** Методы remove() и poll() отличаются только в их поведении. Когда очередь пуста, то метод  remove() генерирует исключение, в то время как  метод poll() возвращает null. В ситуациях когда по логике программы вероятность наличия пустой очереди не является ошибкой, необходимо использовать метод poll().  
**Источник.** https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Queue.html
 

55. Какую математическую сущность моделирует интерфейс Map?  
 **Ответ.** Map - это объект, который сопоставляет ключи значениям. Карта не может содержать повторяющиеся ключи: каждый ключ может соответствовать не более чем одному значению. Он моделирует абстракцию математической функции.  
Источник. https://docs.oracle.com/javase/tutorial/collections/interfaces/map.html
 

56. Какое основное свойство всех имплементаций интерфейса Map, т.е. что их объединяет независимо от имплементации?  
**Ответ.** Все имплементации интерфейса Map будут предоставлять функциональность для набора объектов, хранящих пару "ключ-значение".  
Источник. https://habr.com/ru/post/237043/
 

57. Реализует ли Map интерфейс Collection?  
**Ответ.** Нет. Иерархия Java Collections Framework состоит из двух отдельных деревьев интерфейсов:  
Первое дерево начинается с интерфейса Collection, который обеспечивает основные функции для последовательности отдельных элементов формируемой по некоторым правилам.  
Второе дерево начинается с интерфейса Map, который обеспечивает основные функции для набора пар объектов “ключ-значение” с возможностью выборки значения по ключу.  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/summary.html  
Эккель Б. Философия Java. 4-е полное изд.- СПб.: Питер, 2021. – стр.327
 

58. Какую структуру данных представляет собой совокупность  
ключей;  
значений; 
пар ключ-значение  
любой имплементации Map?  
**Ответ.** Интерфейс Map предоставляет следующие варианты структур данных: набор ключей (Set), набор значений (Collection), или набор отображений значения ключа (Set).  
Cуществует 3 метода, которые возвращают перечень элементов:  
`keySet()` возвращает множество(Set) ключей;  
`values()` возвращает коллекцию(Collection) значений;  
`entrySet()` возвращает множество(Set) наборов “ключ-значение”.  
Источник. https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Map.html  
https://javarush.ru/groups/posts/2542-otvetih-na-samihe-populjarnihe-voprosih-ob-interfeyse-map

 
59. Какие группы операций определены в интерфейсе Map?  
**Ответ.** Также как и в интерфейсе Collection cуществует разделение на 2 основные группы операций:  
- необязательные операции (методы добавления и удаления). Это означает, что реализация класса не обязана предоставлять работоспособные определения таких методов.  
- обязательные операции (методы чтения).  
**Источник.** Эккель Б. Философия Java. 4-е полное изд.- СПб.: Питер, 2021. – стр.653
 

60. Какой интерфейс представляет мультикарту (multimap) в Collections Framework?  
**Ответ.** MultiMap<K, V> фактически является подтипом Map<K, Collection<V>>.  
Multimap - это коллекция, которая сопоставляет ключи со значениями, аналогично java.util.Map, но в которой каждый ключ может быть связан с несколькими значениями. Если добавить два значения для одного и того же ключа, второе значение не переопределит первое значение. Вместо этого у нас будет два значения в результирующей карте.   
**Источник.** https://docs.oracle.com/cd/E14571_01/apirefs.1111/e13403/oracle/javatools/util/MultiMap.html  
https://www-baeldung-com.translate.goog/guava-multimap?_x_tr_sl=auto&_x_tr_tl=ru&_x_tr_hl=ru&_x_tr_pto=nui
 

61. Дана карта:  
Map<K, V> map = …;  
Приведите идиому для выполнения метода void doAction(K key, V value) со всеми элементами карты.  
**Ответ.** 
```java
public class Runner {
    public static void main(String[] args) {
        Map<K, V> map = new HashMap<>();
        map.put(1, "One");
        map.put(2, "Two");
        map.put(3, "Three");
        map.put(4, "Four");
        doAction(map);
    }
    static public void doAction(Map<K, V> imap) {
        for (Map.Entry<K, V> entry : imap.entrySet()){
            System.out.println(entry.getKey() + ": " + entry.getValue());
        }
    }
}
```  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/map.html


62. Дана карта:  
Map<K, V> map = …;  
в которой нет элементов со значением null.  
Приведите идиому для выполнения метода void doAction(V value) с элементом map, заданным ключом K key.  
**Ответ.**  
```java
public class Runner {
    public static void main(String[] args) {
        Map<Integer, String> map = new HashMap<>();
        map.put(1, "One");
        map.put(2, "Two");
        map.put(3, "Three");
        map.put(4, "Four");
        doAction(map.get(4));
    }
    static public <V> void doAction(V value) {
        System.out.println(value);
    }
}
```  
 

63. Дана карта:  
Map<K, V> map = …;  
в которой есть элементы со значением null.  
Приведите идиому для выполнения метода void doAction(V value) с элементом map, заданным ключом K key.  
**Ответ.**  
```java
public class Runner {
    public static void main(String[] args) {
        Map<Integer, String> map = new HashMap<>();
        map.put(null, null);
        map.put(2, "Two");
        map.put(3, null);
        map.put(4, "Four");
        doAction(map.get(4));
    }
    private static <V> void doAction(V value) {
        if (value != null) {
            System.out.println(value);
        }
    }
}
```


64. Можно ли отрефакторить следующий код? Если да, то сделайте это.  
```java
Purchase purchase = new Purchase("meat", new Byn(100), 10);
for (Map.Entry<Purchase, WeekDay> entry: purchaseWeekDayMap.entrySet()) {
    if (entry.getKey().equals(purchase)) {
        System.out.println(entry.getKey());
        break;
    }
}
```  
**Ответ.**  
```java
Purchase purchase = new Purchase("meat", new Byn(100), 10);
if (purchaseWeekDayMap.containsKey(purchase)) {
        System.out.println(purchase);
}  
```  
 

65. Что возвращает метод put интерфейса Map?  
**Ответ.** Помещает в коллекцию новый объект с ключом k и значением v. Если в коллекции уже есть объект с подобным ключом, то он перезаписывается.  
Возвращает предыдущее значение для ключа k, если он уже был в коллекции. Если же ключа еще не было в коллекции, то возвращается значение `null` (возврат `null` также может указывать на то, что карта ранее ассоциировала `null` ключом, если реализация поддерживает нулевые значения.)  
**Источник.** https://docs.oracle.com/javase/8/docs/api/java/util/Map.html#put-K-V-  
 

66. Почему интерфейс Map не расширяет интерфейс Collection в Java Collections Framework?  
**Ответ.** Коллекция принимает элементы одного значения. Карта принимает записи пар ключ/значение. Они могли бы быть спроектированы для повторного использования одного и того же общего интерфейса, однако некоторые методы, которые они реализуют, несовместимы, например.  
`Collection.remove(Object)` - removes an element.  
`Map.remove(Object)` - removes by key, not by entry.  
Можно смоделировать карту как коллекцию записей, что и делает Map.entrySet().  
Есть несколько общих методов; size(), isEmpty(), clear(), putAll/addAll(), но вряд ли они будут иметь большое значение как автономный интерфейс. (Вместо этого можно использовать Map.entrySet()).  
**Источник.** https://overcoder.net/q/544206/%D0%BF%D0%BE%D1%87%D0%B5%D0%BC%D1%83-map-%D0%BD%D0%B5-%D1%80%D0%B0%D1%81%D1%88%D0%B8%D1%80%D1%8F%D0%B5%D1%82-%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81-collection-duplicate
 

67. Дайте определение понятию имплементация (Implementation) в контексте Collections Framework.  
**Ответ.** Имплементация - это объекты данных, используемые для хранения коллекций, которые реализуют интерфейсы.  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/implementations/summary.html  
 

68. Какие виды имплементаций можно выделить?  
**Ответ.** Платформа Java Collections Framework предоставляет несколько универсальных реализаций основных интерфейсов:  
Для интерфейса Set чаще всего используется HashSet.  
Для интерфейса List наиболее часто используемой реализацией является ArrayList.  
Для интерфейса карты HashMap - наиболее часто используемая реализация.  
Для интерфейса Queue чаще всего используется LinkedList.  
Для интерфейса Deque наиболее часто используемой реализацией является ArrayDeque.  
Каждая из универсальных реализаций предоставляет все необязательные операции, содержащиеся в ее интерфейсе.  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/implementations/summary.html  
 

69. На что влияет выбор имплементации?  
**Ответ.** Выбор имплементации влияет на то, какая структура данных будет реализована.  
???
 

70. Идиома создания пустой коллекции имеет следующий вид:   
SomeInterface<Entity> entities = new SuitableImplementation<>();  
Почему в левой части идиомы используется ссылка на интерфейс, а не на имплементацию?  
**Ответ.** В качестве типа ссылки по возможности указывают базовый тип/абстракцию, поскольку это позволяет отвязать нашу переменную от конкретной реализации и в будущем мы можем хранить в ней любой наследник/реализацию (HashMap, HashTable, TreeMap, WeakHashMap, LinkedHashMap, IdentityHashMap).  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/set.html 
 

71. Укажите наиболее часто используемые имплементации для интерфейсов Collections Framework, а также структуру данных, которая поддерживается данной имплементацией.  
Результат представьте в виде таблицы:  
Interface    Implementation    Abstract Data Type  
-----------------------------------------------------------------------
**Ответ.**  
```java
Interface | Implementation | Abstract Data Type  
-------------------------------------------------------------------------------------------------------------------------------------------------------  
Map         HashMap          структура данных, которая реализует интерфейс Map<Ключ, значение> и основана на принципе хеширования. 
 
            LinkedHashMap    упорядоченная реализация хэш-таблицы, в которой имеются двунаправленные связи между элементами.  

            TreeMap          структура данных, которая реализует Map<Ключ,значение> интерфейс и основана на красно-черной структуре данных дерева.  
-------------------------------------------------------------------------------------------------------------------------------------------------------  
List        ArrayList        структура данных, которую можно растянуть, чтобы вместить в себя дополнительные элементы и уменьшить ее до меньшего размера при удалении элементов.  

            LinkedList       динамически изменяемая структура данных, которая строится из набора объектов (узлов Nodes), ссылающихся друг на друга  
-------------------------------------------------------------------------------------------------------------------------------------------------------  
Set         HashSet          это одна из фундаментальных структур данных в Java Collections API.  
                             Он хранит уникальные элементы и допускает нули. Поддерживается хэш-картой.  
                             Он не поддерживает порядок вставки. Это не потокобезопасно  

            LinkedHashSet    упорядоченная версия HashSet, которая поддерживает двусвязный список для всех элементов. Когда необходимо поддерживать порядок итераций.  

            TreeSet          представляет структуру данных в виде дерева, в котором все объекты хранятся в отсортированном виде по возрастанию.  
--------------------------------------------------------------------------------------------------------------------------------------  
```
**Источник.** https://javascopes.com/hashmap-and-treemap-in-java-differences-and-similarities-60da9b2e/  
http://java-online.ru/java-map.xhtml  
https://ru.stackoverflow.com/questions/579288/%D0%A1%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-java-linkedlist#:~:text=%D0%A1%D0%B2%D1%8F%D0%B7%D0%BD%D1%8B%D0%B9%20%D1%81%D0%BF%D0%B8%D1%81%D0%BE%D0%BA%20(LinkedList)%20%2D%20%D1%8D%D1%82%D0%BE,%D0%BD%D0%B0%20%D0%B4%D1%80%D1%83%D0%B3%D0%B0%20(%D1%81%D0%BC.%20%D1%80%D0%B8%D1%81%D1%83%D0%BD%D0%BE%D0%BA%20%D0%BD%D0%B8%D0%B6%D0%B5)  http://java-online.ru/java-map.xhtml  
https://metanit.com/java/tutorial/5.5.php#:~:text=%D0%9E%D0%B1%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%BD%D1%8B%D0%B9%20%D0%BA%D0%BB%D0%B0%D1%81%D1%81%20TreeSet%3CE%3E%20%D0%BF%D1%80%D0%B5%D0%B4%D1%81%D1%82%D0%B0%D0%B2%D0%BB%D1%8F%D0%B5%D1%82%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%83,%D0%B0%20%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%2C%20%D0%B8%20%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81%20SortedSet  
http://espressocode.top/linkedhashset-in-java-with-examples/


72. Приведите идиому создания очереди.  
Xxx<Integer> queue = ...;  
Xxx - это подходящий интерфейс.  
Добавьте 3 элемента и удалите 1, выведя содержимое на консоль.  
**Ответ.** Очереди обычно, но не обязательно, упорядочивают элементы по принципу FIFO (first-in-first-out). 
```java
Queue<Integer> queue = new LinkedList<>();
queue.add(1);
queue.add(2);
queue.add(3);
queue.remove(3); // удаление по элементу
//queue.poll();  // если нужно удалять первый элемент очереди
System.out.println(queue); // output: [1, 2]
```  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/queue.html
 

73. Приведите идиому создания стека.  
Xxx<Integer> stack = ...;  
Xxx - это подходящий интерфейс.  
Добавьте 3 элемента и удалите 1, выведя содержимое на консоль.  
**Ответ.** Класс Stack представляет стек объектов в порядке очереди LIFO (last-in, first-out). Он расширяет класс Vector пятью операциями, которые позволяют рассматривать вектор как стек.  
```java
Deque<Integer> stack = new ArrayDeque<>();
stack.push(1);
stack.push(2);
stack.push(3);
//stack.remove(3); // удаление по элементу
stack.pop(); // метод возвращает элемент, находящийся в верхней части стэка, удаляя его в процессе.
System.out.println(stack); // output: [2, 1]
```  
**Источник.** https://docs.oracle.com/javase/7/docs/api/java/util/Stack.html


74. Когда целесообразно использовать реализацию TreeSet вместо HashSet?  
**Ответ.** HashSet намного быстрее, чем TreeSet (постоянное время и время регистрации для большинства операций, таких как добавление, удаление и удержание), но не дает никаких гарантий упорядочения, таких как TreeSet.  
У HashSet производительность итерации зависит от начальной емкости и коэффициента загрузки HashSet.  
TreeSet не предлагает никаких параметров настройки для выполнения итерации. Однако предлагает несколько удобных методов для работы с упорядоченным набором, таких как first(), last(), headSet(), tailSet() и т. д.  
Таким образом, выбор использования полностью зависит от впотребностей. Даже если нужна упорядоченная коллекция, лучше предпочесть HashSet для создания набора, а затем преобразовать его в TreeSet.  
**Источник.** https://csharpcoderr.com/1958/

 

75. Опишите неупорядоченные реализации Map.  
**Ответ.** 
- Hashtable - реализация такой структуры данных, как хэш-таблица. Она не позволяет использовать `null` в качестве значения или ключа. Hashtable является синхронизированной (почти все методы помечены как synchronized). Из-за этой особенности у неё имеются существенные проблемы с производительностью и, начиная с Java 1.2, в большинстве случаев рекомендуется использовать другие реализации интерфейса Map ввиду отсутствия у них синхронизации.  
- HashMap - коллекция является альтернативой Hashtable. Двумя основными отличиями от Hashtable являются то, что HashMap не синхронизирована и HashMap позволяет использовать `null` как в качестве ключа, так и значения. Так же как и Hashtable, данная коллекция не является упорядоченной: порядок хранения элементов зависит от хэш-функции. Добавление элемента выполняется за константное время O(1), но время удаления, получения зависит от распределения хэш-функции. В идеале является константным, но может быть и линейным O(n).  
- WeakHashMap - реализация хэш-таблицы, которая организована с использованием weak references. Другими словами, Garbage Collector автоматически удалит элемент из коллекции при следующей сборке мусора, если на ключ этого элеметна нет жёстких ссылок.  
**Источник.** https://docs.oracle.com/javase/8/docs/api/java/util/Hashtable.html  
https://docs.oracle.com/javase/8/docs/api/java/util/WeakHashMap.html  
https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html
 

76. Опишите упорядоченные реализации Map.  
**Ответ.** 
- LinkedHashMap - это упорядоченная реализация хэш-таблицы. Порядок итерирования равен порядку добавления элементов. Данная особенность достигается благодаря двунаправленным связям между элементами (аналогично LinkedList). Но это преимущество имеет также и недостаток - увеличение памяти, которое занимает коллекция.  
- TreeMap - реализация Map основанная на красно-чёрных деревьях. Как и LinkedHashMap является упорядоченной. По-умолчанию, коллекция сортируется по ключам с использованием принципа "natural ordering", но это поведение может быть настроено под конкретную задачу при помощи объекта Comparator, который указывается в качестве параметра при создании объекта TreeMap.  
**Источник.** https://habr.com/ru/post/237043/ 


77. Чем отличается ArrayList и LinkedList?  
**Ответ.** ArrayList это список, реализованный на основе массива, а LinkedList - это классический связный список, основанный на объектах с ссылками между ними.  
Преимущества ArrayList: в возможности доступа к произвольному элементу по индексу за постоянное время (так как это массив), минимум накладных расходов при хранении такого списка, вставка в конец списка в среднем производится так же за постоянное время. Удаление последнего элемента происходит за константное время. Недостатки ArrayList проявляются при вставке/удалении элемента в середине списка - это вызывает перезапись всех элементов размещенных «правее» в списке на одну позицию влево, кроме того, при удалении элементов размер массива не уменьшается, до явного вызова метода trimToSize().  
LinkedList наоборот, за постоянное время может выполнять вставку/удаление элементов в списке (именно вставку и удаление, поиск позиции вставки и удаления сюда не входит). Доступ к произвольному элементу осуществляется за линейное время (но доступ к первому и последнему элементу списка всегда осуществляется за константное время - ссылки постоянно хранятся на первый и последний элемент, так что добавление элемента в конец списка вовсе не значит, что придется перебирать весь список в поисках последнего элемента).  
В целом же, LinkedList в абсолютных величинах проигрывает ArrayList и по потребляемой памяти и по скорости выполнения операций.  
LinkedList предпочтительно применять, когда происходит активная работа (вставка/удаление) с серединой списка или в случаях, когда необходимо гарантированное время добавления элемента в список.  
**Источник.** https://habr.com/ru/post/162017/ 


78. Что такое вычислительная сложность операции (алгоритма)?  
**Ответ.** Для оценки сложности алгоритмов в программировании создали специальное обозначение - Big-O - позволяет оценить, насколько время выполнения алгоритма зависит от переданных в него данных.  
Самые часто встречающиеся сложности алгоритмов в коллекциях:  
Получение элемента коллекции O(1)  
Перебор коллекции O(n)  
Вложенные циклы по коллекции O(n^2)  
Поиск в отсортрованой коллекции O(log n)  
**Источник.** https://javarush.ru/groups/posts/2325-slozhnostjh-algoritmov 


79. Укажите вычислительную сложность для операций получения элемента по индексу, поиска, вставки и удаления, для основных коллекций.  
**Ответ.**  
```java
                     Индекс  Поиск     Вставка     Удаления  
ArrayList             O(1)   O(n)       O(n)       O(n)         
Vector                O(1)   O(n)       O(n)       O(n)           
LinkedList            O(n)   O(n)       O(1)       O(1)         
HashTable             n/a    O(n)       O(n)       O(n)      
HashMap               n/a    O(n)       O(n)       O(n)       
LinkedHashMap         n/a    O(n)       O(n)       O(n)          
TeeMap                n/a    O(log(n))  O(log(n))  O(log(n))
HashSet               n/a    O(n)       O(n)       O(n)      
LinkedHashSet         n/a    O(n)       O(n)       O(n)      
TreeSet               n/a    O(log(n))  O(log(n))  O(log(n))
```
**Источник.** https://habr.com/ru/post/237043/ 
 

80. В чем разница между интерфейсами Comparable и Comparator?  
**Ответ.** Comparable это интерфейс, реализация которого обеспечивает естественный порядок для класса, который позволяет автоматически сортировать объекты этого класса.  
Comparator это интерфейс, реализация которого позволяет отсортировать объекты в порядке, отличном от их естественного порядка или предоставляет возможность отсортировать объекты, которые не реализуются Comparable.  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/order.html
 

81. В чем разница между Iterator и ListIterator?  
**Ответ.** Iterator - это объект, который позволяет перемещаться по коллекции и при желании выборочно удалять элементы из коллекции.  
ListIterator - расширенный итератор, который позволяет перемещаться по списку в любом направлении, изменять список во время итерации и получать текущую позицию итератора.  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/list.html 


82. Почему в классе Iterator нет метода для получения следующего элемента без передвижения курсора?  
**Ответ.** Метод можно реализовать поверх текущего интерфейса Iterator, но, поскольку его использование будет редким, нет смысла включать его в интерфейс, который каждый должен реализовать.  
**Источник.** Cracking The Programming Interview: 2000+ Java Que. & Ans. Paperback – August 1, 2014 by Harry. Anonymous Hacktivist - 321 page.    


83. Назовите высокопроизводительные реализации Set для перечислимых типов (enum)?  
**Ответ.** EnumSet - класс специально реализован для работы с типами `enum`. Все элементы такой коллекции должны принадлежать единственному типу `enum`, определенному явно или неявно. Внутренне множество представимо в виде вектора битов, обычно единственного long. Множества нумераторов поддерживают перебор по диапазону из нумераторов. Скорость выполнения операций над таким множеством очень высока, даже если в ней участвует большое количество элементов.  
**Источник.**  https://docs.oracle.com/javase/8/docs/api/java/util/EnumSet.html 


84. Как происходит удаление элементов из ArrayList? Как меняется в этом случае размер ArrayList?  
**Ответ.** Удалить элемент из ArrayList можно при помощи метода remove(), передав в аргумент индекс или значение элемента. Для удаление элемента во время прохода по циклу, для избежания ConcurrentModificationException, нужно использовать Iterator.  
При удалении произвольного элемента из списка, все элементы находящиеся «правее» смещаются на одну ячейку влево и реальный размер массива (его емкость, capacity) не изменяется никак. Механизм автоматического «расширения» массива существует, а вот автоматического «сжатия» нет, можно только явно выполнить «сжатие» командой trimToSize().  
**Источник.** https://habr.com/ru/post/162017/


85. Можно ли использовать массив в качестве ключа для HashMap? Если да, то какие есть особенности.  
**Ответ.** Хеш-код массива не зависит от хранимых в нем элементов, а присваивается при создании массива (метод вычисления хеш-кода массива не переопределен и вычисляется по стандартному Object.hashCode() на основании адреса массива). Так же у массивов не переопределен equals() и выполняет сравнение указателей. Это приводит к тому, что обратиться к сохраненному с ключом-массивом элементу не получится при использовании другого массива такого же размера и с такими же элементами, доступ можно осуществить лишь в одном случае - при использовании той же самой ссылки на массив, что использовалась для сохранения элемента.  
**Источник.**  https://habr.com/ru/post/162017/ 


86. Где определены полиморфные алгоритмы для работы с коллекциями? Опишите основные группы.    
**Ответ.** Полиморфные алгоритмы являются частями многократного использования функциональных возможностей, предоставляемых платформой Java. Все они происходят из Collections и все принимают форму статических методов, первым аргументом которых является коллекция, над которой должна выполняться операция. Подавляющее большинство алгоритмов, предоставляемых платформой Java, работают с List-экземплярами, но некоторые из них работают с произвольными Collection экземплярами.  
Основные группы:  
- Sorting - алгоритм сортирует коллекцию так, что ее элементы становяться в порядке возрастания.  
- Shuffling - этот алгоритм переупорядочивает коллекцию на основе источника случайности, так что все возможные перестановки происходят с равной вероятностью, предполагая справедливый источник случайности.  
- Routine Data Manipulation - пять алгоритмов делает рутинную обработку данных: reverse(меняет порядок элементов), fill(перезаписывает каждый элемент в указанном значении), copy(принимает два аргумента, место назначения и источник, и копирует элементы источника в место назначения, перезаписывая его содержимое), swap(меняет местами элементы в указанных позициях), addAll(добавляет все указанные элементы в Collection).  
- Searching - поисках для заданного элемента.  
- Composition - Частотный и непересекающийся алгоритмы. Частотный подсчитывает, сколько раз указанный элемент встречается в указанной коллекции. Непересекающийся - содержат ли коллекции общие элементы.  
- Finding Extreme Values - возвращают минимальный и максимальный элемент, содержащийся в указанных Collection.  
**Источник.**  https://docs.oracle.com/javase/tutorial/collections/algorithms/index.html


87. В чем заключается назначение метода Collections.unmodifiableCollection(Collection<? extends T> c)?    
**Ответ.** `Collections.unmodifiableCollection()` получает исходную коллекцию и возвращает её копию, пригодную только для чтения.  
**Источник.** Философия Java. 4-е полное изд. - СПб.: Питер, 2015. - 710 c. 


88. Перечислите различия между массивами и коллекциями?  
**Ответ.**  
```java
                      Массив                     Коллекция        

Размер                фиксированный размер        динамический размер         

Потребление памяти    потребляет больше памяти    потребляет меньше памяти

Тип данных            могут содержать только      может содержать как однородные,
                      один и тот же тип данных    так и разнородные элементы       

Хранилище примитивов  могут содержать данные      может содержать только типы объектов,
                      как объектного, так и       но не примитивный тип данных
                      примитивного типа

Производительность    лучшая производительность  низкая производительность
                      по сравнению с коллекциями по сравнению с массивами
```
**Источник.**  https://www.tutorialspoint.com/difference-between-arrays-and-collection-in-java


89. Массивы и коллекции являются ковариантными или инвариантными? Поясните ответ.  
**Ответ.** Массивы отличаются от обобщенных типов двумя важными аспектами. Прежде всего, массивы ковариантны. Это означает, что если Sub является подтипом Super, то тип массива Sub[] является под­типом Super[]. Обобщенные типы, напротив, инвариантны: для любых двух различных типов Type1 и Туре2 тип List<Typel> не является ни подтипом, 
ни супертипом List<Type2>.  
Соответственно массивы - ковариантны, всё остальное - нет.  
**Источник.** Джошуа Блох. Java: эффективное программирование, 3-е изд. 2019. стр. 168 


90. Дано:  
SortedSet<Entity> set = ...;  
Найдите в jdk тип 1, для которого SortedSet<Entity> является подтипом.  
подтип 2 для SortedSet<Entity>.  
Создайте множество set1 типа 1 и множество set2 подтипа 2. Проверьте правильность, сделав присваивания:  
set1 = set;  
set = set2;  
**Ответ.**  
```java
    SortedSet<Entity> set = new TreeSet<>();        
    Set<Entity> set1 = new HashSet<>(); // тип 1, для которого SortedSet<Entity> является подтипом.        
    SortedSet<Entity> set2 = new ConcurrentSkipListSet<>(); // подтип 2 для SortedSet<Entity>.       
    set1 = set;  
    set = set2;
```
**Источник.** https://docs.oracle.com/javase/tutorial/java/generics/inheritance.html 


91. Массивы и коллекции являются reified (овеществленные) или non-reified типами? Поясните ответ.    
**Ответ.** Массивы являются типами, доступными при выполнении (reified). Это значит, что массивы знают тип элементов во время выполнения и обеспечивают его.  
Обобщенные типы, напротив, реализуются с использованием затирания (erasure). Это значит, что они обеспечивают ограничения на типы только на этапе компиляции, а затем отбрасывают (или затирают) информацию о типах элементов при выполнении. Затирание позволяет обобщенным типам свободно взаимодействовать со старым кодом, который не использует обобщенные типы, обеспечивая плавный переход к обобщенным типам в Java 5.  
Соответственно массивы - reified, всё остальное - нет.  
**Источник.** Джошуа Блох. Java: эффективное программирование, 3-е изд. 2019. стр. 169 