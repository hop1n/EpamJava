1. Что такое исключения?  
**Ответ.** Исключительные ситуации (исключения) и ошибки возникают во время выполнения программы,  когда  появившаяся  проблема  не  может  быть  решена в текущем контексте и невозможно продолжение работы программы. Обычно считается, что исключения и ошибки — тождественные понятия.  
**Источник.** Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик, 2020. – 264 с.  

2. Какие действия производит система времени выполнения при возникновении исключения?  
**Ответ.** При возникновении исключения в приложении создается объект, описывающий это исключение. Затем текущий ход выполнения приложения останавливается, и включается механизм обработки исключений. При этом ссылка на объект-исключение передается обработчику исключений, который пытается решить возникшую проблему и продолжить выполнение программы. Если в классе используется метод, в котором может возникнуть проверяемая исключительная ситуация, но не предусмотрена ее обработка, то ошибка возникает еще на этапе компиляции.  
**Источник.** Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик, 2020. – 264 с.  

3. Как называется блок кода, который обрабатывает исключение?  
**Ответ.** На практике используется один из двух способов обработки исключений:  
•  перехват и обработка исключения в блоке try-catch метода;  
•  объявление исключения в секции throws метода и передача вызывающему методу (в первую очередь для проверяемых исключений).  
**Источник.** Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик, 2020. – 268 с.  

4. Как реализуется требование «Поймай или Укажи» (Catch or Specify)?  
**Ответ.** Код, который может вызывать исключения, должен быть заключен в блок `try`, либо метод котором либо в заголовке такого метода должна стоять конструкция: `throws <ExceptionClassName>`.  
**Источник.** https://docs.oracle.com/javase/tutorial/essential/exceptions/catchOrDeclare.html  

5. Какая иерархия классов исключений?  
**Ответ.** Каждой исключительной ситуации поставлен в соответствие некоторый класс, экземпляр которого инициируется при ее появлении. Если подходящего класса не существует, то он может быть создан разработчиком. Все исключения являются наследниками суперкласса `Throwable` и его подклассов `Error` и `Exception` из пакета `java.lang`.  
**Источник.** Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик, 2020. – 268 с.  

6. Какие виды исключений относятся к непроверяемым?  
**Ответ.** В отличие от проверяемых исключений, класс `RuntimeException` и порожденные от него классы относятся к непроверяемым исключениям. Компилятор не проверяет, может ли генерировать и/или обрабатывать метод эти исключения. Исключения типа `RuntimeException` генерируются при возникновении ошибок во время выполнения приложения.  
**Источник.** Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик, 2020. – 265-266 с.  

7. Какие компоненты могут входить в обработчик исключений?  
**Ответ.** `try-catch- finally`  
Каждому разделу `try` должен соответствовать по крайней мере один раздел `catch` или блок `finally`.  
**Источник.** Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик, 2020. – 277 с.  

8. Для каких ситуаций используется оператор try-with-resources?  
**Ответ.** Java-библиотеки включают множество ресурсов, которые должны быть закрыты вручную с помощью вызова метода `close`. Примеры включают `Inputstream`, `Outputstream` и `java.sql.Connection`. Закрытие ресурсов часто забывается клиентами, с предсказуемо неприятными последствиями. Все эти проблемы были решены одним махом, когда в `Java 7` была введена инструкция try-with-resources. Для использования этой конструкции ресурс должен реализовывать интерфейс `AutoCloseable`, который состоит из единственного ничего не возвращающего метода `close`.  
**Источник.** Java: эффективное программирование, 3-е изд. : Блох, Джошуа 2019. - 65 с.  

9. Какой код заключается в блок try?  
**Ответ.** Операторы программы, которые требуется отслеживать на предмет исключений, размещаются в блоке `try`. Если исключение возникает в блоке `try`, оно генерируется.  
**Источник.** Java.  Полное руководство, 10-е изд. : Шилдт, Герберт 2018. - 279с.  

10. Выполняется ли весь код блока try в случае возникновения исключения?  
**Ответ.** Если фрагмент кода в блоке оператора `try` генерирует исключение типа, указанного в заголовке блока оператора `catch`, то происходит следующее.   
1) Программа пропускает оставшуюся часть кода в блоке оператора `try`.   
2) Программа выполняет код обработчика в блоке оператора `catch`.  
**Источник.** Java. Библиотека профессионала, том 1.  Основы. 11-е изд.: Хорстманн, Кей С. 2019. – 348с.  

11. Может ли использоваться только один блок try (без catch или finally)?  
**Ответ.** Операторы try и catch составляют единое целое. Область действия блока оператора `саtch` не распространяется на операторы, предшествующие блоку оператора try.  
**Источник.** Java.  Полное руководство, 10-е изд. : Шилдт, Герберт 2018. –283с.  

12. Какое назначение блока catch?  
**Ответ.** Прикладной код может перехватить исключение, используя блок `catch`, а затем обработать его некоторым рациональным способом.  
**Источник.** Java.  Полное руководство, 10-е изд. : Шилдт, Герберт 2018. –279с.  

13. Сколько блоков catch может содержаться после try-оператора?  
**Ответ.** Если в блоке try может быть сгенерировано в разных участках кода несколько типов исключений, то необходимо наличие нескольких блоков catch, если только блок catch не обрабатывает все типы исключений.  
**Источник.** Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик, 2020. – 269 с.  

14. Если применяется несколько блоков catch, то в каком порядке в случае возникновения исключения они вызываются?  
**Ответ.** Когда генерируется исключение, каждый оператор catch проверяется по порядку, и выполняется тот из них, который совпадает по типу с возникшим исключением. По завершении одного из операторов catch все остальные пропускаются, и выполнение программы продолжается с оператора, следующего сразу за блоком операторов try/catch.  
**Источник.** Java.  Полное руководство, 10-е изд. : Шилдт, Герберт 2018. –284-285с.  

15. Какой код может быть между блоками try и catch?  
**Ответ.** Операторы try и catch составляют единое целое и между ними не может быть другого кода.  

16. Может ли использоваться блок catch без блока try?  
**Ответ.** Операторы try и catch составляют единое целое.  
**Источник.** Java.  Полное руководство, 10-е изд. : Шилдт, Герберт 2018. –283с.  

17. Сколько типов исключений может обрабатывать один блок catch?  
**Ответ.** До Java SE 7 один блок catch мог обработать 1-н исключение, но в Java SE 7 появился Catching Multiple и количество исключений в одном блоке catch стало не ограничено.  
**Источник.** https://docs.oracle.com/javase/7/docs/technotes/guides/language/catch-multiple.html  

18. В случае отсутствия исключения в блоке try выполняется ли блок catch?  
**Ответ.** Если код в блоке оператора try не генерирует исключение, то программа пропускает блок оператора catch. А если какой-нибудь из операторов из блока try сгенерирует исключение, отличающееся от типа, указанного в блоке catch, то выполнение данной части программы (в частности, вызываемого метода) немедленно прекращается.  
**Источник.** Java. Библиотека профессионала, том 1.  Основы. 11-е изд.: Хорстманн, Кей С. 2019. – 348с.  

19. Для чего используется блок finally?  
**Ответ.** Возможна ситуация, при которой нужно выполнить некоторые действия по завершении программы (закрыть поток, освободить соединение с базой данных) вне зависимости от того, произошло исключение или нет. В этом случае используется блок finally, который обязательно выполняется после или инструкции try, или catch.  
**Источник.** Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик, 2020. – 277 с.  

20. В случае отсутствия исключения в блоке try выполняется ли блок finally (при его наличии)?  
**Ответ.** Оператор finally образует блок кода, который будет выполнен по завершении блока операторов try/catch, но перед следующим за ним кодом. Блок оператора `finally` выполняется независимо от того, сгенерировано исключение или нет.  
**Источник.** Java.  Полное руководство, 10-е изд. : Шилдт, Герберт 2018. –292 с.  

21. Могут ли использоваться блоки try-finally без блока catch?  
**Ответ.** Иногда объекту нужно выполнять некоторые действия перед освобождением памяти. Например, освободить внешние ресурсы. Для обработки таких ситуаций могут применяться два способа: конструкция try-finally и механизм autocloseable.  
**Источник.** Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик, 2020. – 277 с.  

22. Приведите пример кода, в котором используется оператор try-with-resources.  
**Ответ.**   
```java  
public class DemoTryWithResources {  
    public static String firstLineOfFile(String path, String defaultVal) {  
        try (BufferedReader br = new BufferedReader(new FileReader(path))) {  
            return br.readLine();  
        } catch (IOException e) {  
            return defaultVal;  
        }  
    }  
}  
```  
**Источник.** Java: эффективное программирование, 3-е изд. : Блох, Джошуа 2019. - 66 с.  

23. Какой оператор может использоваться вместо try-with-resources?  
**Ответ.** try-catch-finally или try-finally  

24. Может ли применяться оператор try-with-resources совместно с блоком finally?  
**Ответ.** Блок finally выполняется всегда по завершении блока try/catch, независимо от того, какое именно условие к этому привело.  Следовательно, блок finally получит управление как при нормальной работе программы, так и при возникновении ошибки. Более того, он будет вызван даже в том случае, если в блоке try или в одном из блоков catch будет присутствовать оператор return для немедленного возврата из метода.  
**Источник.** Java 8: руководство для начинающих, 6-е изд. : Шилдт, Герберт 2015. –339 с.  

25. Какое ключевое слово используется в сигнатуре метода, чтобы указать на возможность выбрасывания им исключения?  
**Ответ.** Если метод способен вызвать исключение, которое он сам не обрабатывает, то он должен задать свое поведение таким образом, чтобы вызывающий его код мог обезопасить себя от такого исключения. С этой целью в объявление метода вводится оператор throws, где перечисляются типы исключений, которые метод может генерировать.  
**Источник.** Java.  Полное руководство, 10-е изд. : Шилдт, Герберт 2018. –290 с.  

26. Сколько исключений может выбрасывать метод?  
**Ответ.** Неограниченное количество. Как пример общая форма объявления метода:  
```java
возвращаемый_тип  имя_метода(список_параметров) throws список исключений {   
	//  Тело  метода   
}
```
**Источник.** Java 8: руководство для начинающих, 6-е изд. : Шилдт, Герберт 2015. –340 с.  

27. Какое ключевое слово используется для гарантированного выбрасывания исключения?  
**Ответ.** Для генерации исключительной ситуации и создания экземпляра исключения используется оператор throw.  
**Источник.** Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик, 2020. – 272 с.  

28 Можно ли создавать свои собственные классы исключений?  
**Ответ.** Для повышения качества и скорости восприятия кода разработчику следует создать собственное исключение как подкласс класса Exception, а затем использовать его при обработке ситуации, не являющейся исключением с точки зрения языка, но нарушающей логику вещей. По соглашению наcледник любого класса-исключения должен заканчиваться словом Exception.  
**Источник.** Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик, 2020. – 274 с.  

29. Приведите примеры наиболее известных подклассов класса Exception.  
**Ответ.** Ошибки, связанные с работой программы, представлены отдельными подклассами, производными от класса Exception.  В частности это RuntimeException, IOException, ClassNotFoundException, NoSuchMethodException, IllegalAccessException.  
**Источник.** Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик, 2020. – 266 с.  

30. Приведите примеры наиболее известных подклассов класса RuntimeException.  
**Ответ.**   
ArithmeticException - Арифметическая ошибка: деление на ноль и др.  
ArrayIndexOutOfBoundsException - Индекс массива находится вне его границ  
ArrayStoreException - Назначение элементу массива несовместимого типа  
ClassCastException - Недопустимое приведение типов  
ConcurrentModificationException - Некорректный способ модификации коллекции  
IllegalArgumentException - При вызове метода использован некорректный аргумент  
IllegalMonitorStateException - Незаконная операция монитора на разблокированном   
объекте  
IllegalStateException - Среда или приложение находятся в некорректном   
состоянии  
IllegalThreadStateException - Требуемая операция не совместима с текущим   
состоянием потока  
IndexOutOfBoundsException - Некоторый тип индекса находится вне границ коллекции  
NegativeArraySizeException - Попытка создания массива с отрицательным размером  
NullPointerException - Недопустимое использование  ссылки  на null  
NumberFormatException - Невозможное преобразование строки в числовой формат  
StringIndexOutOfBoundsException - Попытка индексации вне границ строки  
MissingResourceException - Отсутствие файла ресурсов properties или имени   
ресурса в нем  
EnumConstantNotPresentException - Несуществующий элемент перечисления  
UnsupportedOperationException - Встретилась неподдерживаемая операция  
**Источник.** Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик, 2020. – 267 с.  

31. Что такое сцепление исключений?  
**Ответ.** В тех случаях, когда исключение нижнего уровня может быть полезно для анализа ситуации, вызвавшей исключение, лучше использовать особый вид трансляции исключений, называемый цепочкой (сцеплением) исключений (exception chaining).  
**Источник.** Java: эффективное программирование, 3-е изд. : Блох, Джошуа 2019. - 371 с.  

32. Приведите пример кода со сцеплением исключений.  
**Ответ.**   
```java  
public class DemoExceptionChaining {  
    public static String doSomething() {  
        try {  
            // some code  
        } catch (LowerLevelException cause) {  
            throw new HigherLevelException(cause);  
        }  
    }  
}  
```  

33. Какая информация приводится при трассировке стека во время исключения?  
**Ответ.** Когда выполнение программы аварийно завершается из-за неперехваченного исключения, система автоматически распечатывает трассировку стека (stack trace) для этого исключения. Трассировка стека содержит строковое представление данного исключения, результат вызова его метода toString. Обычно это представление состоит из названия класса исключения и описания исключения.   
**Источник.** Java: эффективное программирование, 3-е изд. : Блох, Джошуа 2019. - 374 с.  

34. В каких случаях целесообразно создавать собственный класс исключения?  
**Ответ.** Для повышения качества и скорости восприятия кода разработчику следует создать собственное исключение как подкласс класса Exception, а затем использовать его при обработке ситуации, не являющейся исключением с точки зрения языка, но нарушающей логику вещей. По соглашению наcледник любого класса-исключения должен заканчиваться словом Exception.  
**Источник.** Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик, 2020. – 274 с.  

35. Какой класс исключений может использоваться в качестве суперкласса для собственного исключения?  
**Ответ.** Cледует создать собственное исключение как подкласс класса Exception должен заканчиваться словом Exception.  
**Источник.** Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик, 2020. – 274 с.  

36. Какие исключения целесообразно делать проверяемыми, а какие – непроверяемыми?  
**Ответ.** Основное правило при выборе между проверяемым и непроверяемым исключениями гласит: используйте проверяемые исключения для ситуаций, когда есть основания полагать, что вызывающий код способен выполнить восстановление. Используйте исключения времени выполнения для указания на программные ошибки.  
**Источник.** Java: эффективное программирование, 3-е изд. : Блох, Джошуа 2019. – 362-363 с.  

37. Какие преимущества в механизме выбрасывания и обработки исключений?  
**Ответ.** Стандартный обработчик исключений, предоставляемый исполняющей системой Java, безусловно, удобен для отладки, но, как правило, обрабатывать исключения приходится вручную. Это дает два существенных преимущества. Во-первых, появляется возможность исправить ошибку. И, во-вторых, предотвращается автоматическое прерывание выполнения программы.  
**Источник.** Java.  Полное руководство, 10-е изд. : Шилдт, Герберт 2018. – 282 с.  

38. Можно ли выбрасывать исключения в конструкторах?  
**Ответ.** Да  

39. Может ли произойти потеря исключения? Если да – приведите пример.  
**Ответ.** Блок finally может вызвать потерю исключений.  
```java  
public class ExceptionLossTest{  
    public static void main(String[] args){  
        try {  
            try {  
                throw new Exception("a");  
            } finally {  
                if (true) {  
                    throw new IOException("b");  
                }  
                System.err.println("c");  
            }  
        } catch (IOException ex) {  
            System.err.println(ex.getMessage());  
        } catch (Exception ex) {  
            System.err.println("d");  
            System.err.println(ex.getMessage());  
        }  
    }  
}  
```  
Результатом выполнения будет вывод в консоль b. И только. После инициации первого исключения – new Exception("a") – будет выполнен блок finally, в котором будет брошено исключение new IOException("b"). И именно это исключение будет поймано и обработано. Исходное же исключение теряется.  
**Источник.** http://skipy.ru/technics/exceptions.html  

40. Обладают ли исключения свойством транзакционности?  
**Ответ.** Свойством транзакционности исключения не обладают, так как действия произведенные в блоке try до возникновения исключения, не отменяются после его возникновения.  
**Источник.** http://skipy.ru/technics/exceptions.html  
  
41. Является ли данный код антипаттерном?  
Обоснуйте ответ.   
```java  
void methodCatchesSomeException() {  
        	...  
        	try {  
                    	...  
        	} catch (SomeException ex) {  
                    	...  
        	}  
        	...  
}  
```  
**Ответ.** Нет, присутствует блок try с каким-то кодом который может привести к появлению исключения и присутствует блок catch для перехвата и обработки этого исключения.  

42. Является ли данный код антипаттерном?   
Обоснуйте ответ.   
```java  
void methodThrowsSomeCheckedException() {  
        	...  
        	throw new SomeCheckedException();  
        	...  
}  
```  
**Ответ.** Да, у метода methodThrowsSomeCheckedException отсутствует объявление исключения в секции throws и передача вызывающему методу.  

43. Является ли данный код верным? Укажите почему.  
```java  
void methodThrowsSomeCheckedException() throws SomeCheckedException {  
        	...  
        	throw new SomeCheckedException();  
        	...  
}  
```  
**Ответ.** Да, у метода methodThrowsSomeCheckedException в теле присутствует генерация исключения которое в секции throws передает исключение вызывающему методу.  

44. Приведите примеры кода с выбросом RuntimeException явным образом и в случае программной ошибки.  
**Ответ.**  
```java  
public class Demo_Exception {   
// явным образом  
    void methodThrowsRuntimeException() {  
        throw new NullPointerException();  
    }  
// в случае программной ошибки  
    void methodMakeRuntimeException() {  
        String str = null;  
        str.length();  
    }  
}  
```  

45. Можно ли отрефакторить данный код? Если да, то выполните.  
```java  
void methodThrowsSomeRuntimeException() {  
        	...  
        	throw new SomeRuntimeException();  
        	...  
}  
```  
**Ответ.** Можно добавить информацию об ошибке при генерации исключения SomeRuntimeException().  
```java  
void methodThrowsSomeRuntimeException() {  
        ...  
        throw new SomeRuntimeException("some text");  
        ...  
}  
```  

46. Является ли данный код антипаттерном?   
Обоснуйте ответ.   
```java  
void methodThrowsSomeRuntimeException() throws SomeRuntimeException {  
        	...  
        	throw new SomeRuntimeException();  
        	...  
}  
```  
**Ответ.** Да. Для исключений, являющихся подклассами класса RuntimeException (unchecked) и используемых для отображения программных ошибок, при выполнении приложения в объявлении метода секция throws может отсутствовать, так как играет только информационную роль.  
**Источник.** Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик, 2020. – 276 с.  

47. В какой версии Java появился оператор try-with-resources? Приведите пример кода с использованием указанного оператора.  
**Ответ.** Java SE 7  
```java  
  try (Connection connection = DriverManager.getConnection(DB_URL, USER_NAME, PASSWORD);  
        Statement statement = connection.createStatement()) {  
        ...  
    } catch (SQLException ex) {  
         ...  
    }  
```  

48. Является ли данный код антипаттерном?   
Обоснуйте ответ.   
```java  
void methodWithAutocloseableInstance() {  
    ...  
    try(SomeResource res = new SomeResource(...)) {  
      	...  
    }  
      	...  
}  
```  
**Ответ.** Нет, если главным показателем в примере является try-with-resources, так как все ресурсы закрываются по окончанию блока try.  
Да, если считать не показанным в примере наличие блока catch или finally.  

49. Является ли данный код антипаттерном?   
Обоснуйте ответ.   
```java  
void methodWithAutocloseableInstance() {  
        	...  
        	try(SomeResource res = new SomeResource(...)) {  
                    	...  
        	} catch (CorrectCheckedException ex) {  
                    	…  
        	}  
        	...  
}  
```  
**Ответ.** Нет, так как используется try-with-resources и все ресурсы закрываются, а так же присутствует блок catch для обработки исклбючения.  

50. Является ли данный код антипаттерном?   
Обоснуйте ответ.   
```java  
try {  
           …  
}  catch (SomeException е) {  
        	//no code  
}  
```  
**Ответ.** Да. В теле блока catch отсутствует код для обработки или хотя бы логирования исключения.  

51. Является ли данный код антипаттерном?   
Обоснуйте ответ.   
```java  
try {  
        	…  
}  catch (SomeException е) {  
    	System.out.println(“Something went wrong!”);  
}  
```  
**Ответ.** Да, если это консольное приложение и ответ попадает к пользователю. И НЕТ если в приложение консоль предусмотрена именно для логированния исключения (что не лучшее из решений).  

52. Является ли данный код антипаттерном, если блок catch находится не в конце раннер-метода main()?   
Обоснуйте ответ.   
```java  
try {  
    		…  
}  catch (Exception е) {  
    		…  
}  
…  
```   
или другой вариант  
 ```java  
try {  
        	…  
}  catch (Throwable е) {  
        	…  
}  
…  
```  
**Ответ.** Если вопрос именно про нахождение блока catch, то он не обязан располагаться в конце main() если логика задачи этого не требует.   
Если вопрос был на внимательность, то оба варианта используют обобщенные исключения и в этом случае это антипатерн.  
Не используйте Exception, RuntimeException, Throwable и Error непосредственно. Рассматривайте эти классы как если бы они были абстрактными. Нельзя надежно протестировать эти исключения, поскольку они являются суперклассами для других исключений, которые может генерировать метод.  
**Источник.** Java: эффективное программирование, 3-е изд. : Блох, Джошуа 2019. – 368 с.  
  
53. Является ли данный код антипаттерном?   
Обоснуйте ответ.   
```java  
try {  
    	int i = 0;  
  	  while(true) {  
        	а[i++].f();  
        }  
} catch(ArraylndexOutOfBoundsException е) {  
    	…  
}  
```  
**Ответ.** Да. Исключение ArraylndexOutOfBoundsException относится к RuntimeExeption и такие исключения в большинстве случаев это ошибка программирования и попытка её спрятать.  

54. Есть ли недостатки у API написанного только с использованием обрабатываемых исключений?  
**Ответ.** При нечастом использовании проверяемые исключения могут повысить надежность программ. При злоупотреблении они делают использование API болезненным. Если вызывающий код не в состоянии восстановиться после сбоя, генерируйте непроверяемые исключения.  
**Источник.** Java: эффективное программирование, 3-е изд. : Блох, Джошуа 2019. – 367 с.  

55. Даны два варианта сеттера.  
Какой является более предпочтительным в использовании?  
Обоснуйте ответ.   
Вариант 1.  
```java  
void setPositiveValue(int value) {  
        	if(value <= 0) {  
                    	throw new IllegalArgumentException(...);  
        	}  
        	this.value = value;  
}  
```  
Вариант 2.  
```java  
void setPositiveValue(int value) throws SomeCheckedException {  
        	if(value <= 0) {  
                    	throw new SomeCheckedException(...);  
        	}  
        	this.value = value;  
}  
```  
**Ответ.** Вариант 1.  
Повторное использование имеющихся исключений имеет ряд преимуществ.   
Главное среди них то, что они упрощают изучение и применение ваших API, поскольку соответствуют установленным соглашениям, с которыми хорошо знакомы программисты. С этим же связано второе преимущество, заключающееся в том, что программы, использующие ваш API, проще для чтения и понимания, поскольку в них нет незнакомых, сбивающих с толку исключений. Наконец, чем меньше классов исключений, тем меньше требуется места в памяти и времени на их загрузку.    
**Источник.** Java: эффективное программирование, 3-е изд. : Блох, Джошуа 2019. – 367 с.  

56. Приведите пример наиболее распространенных из повторно используемых исключений и причины их применения.  
**Ответ.**  
Чаще всего используется исключение IllegalArgumentException. Обычно оно генерируется, когда вызываемому методу передается аргумент с неправильным значением. Например, IllegalArgumentException может генерироваться в случае, когда в качестве аргумента, указывающего количество повторов некоторого действия, передается отрицательное значение.  
Другое часто используемое исключение — IllegalStateException.   
Обычно оно генерируется, когда вызов является некорректным из-за состояния объекта. Например, это исключение может генерироваться, когда делается попытка использовать некий объект до его надлежащей инициализации.  
```java  
    void doSomething(int index, Object obj) {  
        ...  
        if (index < 0) {  
            throw new IllegalArgumentException();   
        }  
        ...     
        if (obj == null) {  
            throw new IllegalStateException();   
        }  
        ...        
    }  
```  
**Источник.** Java: эффективное программирование, 3-е изд. : Блох, Джошуа 2019. – 368 с.  

57. Если недостаточно информации для принятия решения и...  
1)     исключительная ситуация должна быть исправлена на ближайшем уровне;  
2)     исключительная ситуация маловероятна  
Экземпляры подклассов каких типов исключений целесообразно сгенерировать в каждом случае?  
**Ответ.**  
1 – Пробросить исключение на следующий/ближайший уровень с использованием throws. В этом случае программист будет вынужден как то реагировать на исключение в месте где его вызывается метод его использующий и возможно уже присутствует достаточно информации, что бы отреагировать на него.  
2 – Попытаться организовать проверку этого редкого условия.  

58. Выделите в блоке try-catch основной и альтернативный сценарии.   
Обоснуйте ответ.   
```java  
try {  
        	...  
        	User user = source.getUser(login, password);  
        	if(GUEST_USER.equals(user) {  
                    	…  
        	} else {  
                    	…  
        	}  
        	...  
}  catch (SourceException е) {  
    		…  
}  
class Source {  
        	public User getUser(String login, String password) throws SourceException {  
                    	...  
                    	throw new SourceException(...);  
                    	...  
                    	return GUEST_USER;	//wrong login or password  
                    	...  
                    	return new User(...);  
        	}  
        	...  
}  
```  
**Ответ.** Любая попытка получить user будет приводить к генерации исключения SourceException. Но если не обращать на это внимание то основной сценарий это блок try c попыткой получить user, а альтернативный это блок catch.  

59. Перепишите код предыдущего задания с условием, что ввод неправильных логина или пароля является альтернативным сценарием.  
**Ответ.**  
```java  
        User user = source.getUser(login, password);  
        if (GUEST_USER.equals(user)) {  
                    …  
        } else {  
                    …  
        }  
class Source {  
    public User getUser(String login, String password) {  
                ...  
        return GUEST_USER; // wrong login or password  
                ...  
        return new User();  
    }  
    ...  
}  
```  

60. Что такое трансляция исключения, когда ее используют и какие правила ее использования? Приведите пример трансляции исключения.  
**Ответ.**  
верхние уровни приложения должны перехватывать исключения нижних уровней и, в свою очередь, генерировать исключения, которые можно пояснить в терминах абстракции верхнего уровня. Эта идиома известна как трансляция исключений (exception translation):  
```java  
// Трансляция исключений  
try {  
... // Применение низкоуровневой абстракции  
} catch (LowerLevelException е) {  
    throw new HigherLevelException(...);  
}  
```  
**Источник.** Java: эффективное программирование, 3-е изд. : Блох, Джошуа 2019. – 370 с.  

61. Как можно избежать использования трансляций и зачем нужно это предпринимать?  
**Ответ.** Этого можно добиться путем проверки корректности аргументов метода верхнего уровня перед их передачей на нижний уровень.  
**Источник.** Java: эффективное программирование, 3-е изд. : Блох, Джошуа 2019. – 372 с.  

62. В каких случаях надо предпочесть сцепление трансляции?  
**Ответ.** В тех случаях, когда исключение нижнего уровня может быть полезно для анализа ситуации, вызвавшей исключение, лучше использовать особый вид трансляции исключений, называемый цепочкой (сцеплением) исключений (exception chaining).  
**Источник.** Java: эффективное программирование, 3-е изд. : Блох, Джошуа 2019. – 371 с.  
  
63. Можно ли для исключительной ситуации определить, класс, который не является подклассом Exception, RuntimeException, Error.   
Если да, то как он будет себя проявлять (как checked-exception или как unchecked-exception)?  
**Ответ.** Технически можно наследоваться оставшегося не перечисленным суперкласса Throwable и так как он является checked-exception, то это тоже будет checked-exception.  
  
64. Обязательно ли информацию об исключительное ситуации представлять строковым полем?  
Если нет, то какой альтернативный способ создания строкового представления исключения?  
**Ответ.** Так как исключение является классом в Java и при его возникновении создается новый объект, то нам ничего не мешает создавать создать класс-исключение с любым конструктором принимающем на вход любой примитив или объект.  
  
65. Если метод завершается сбоем, что нужно сделать с объектом, на котором был вызван этот метод?  
**Ответ.** Вызов метода, завершившийся сбоем, должен оставлять проверяемый объект в том же состоянии, в каком тот был перед вызовом.  
**Источник.** Java: эффективное программирование, 3-е изд. : Блох, Джошуа 2019. – 376 с.  
  
66. Приведите способы достижения атомарности по отношению к сбоям.  
**Ответ.**  
Разработке неизменяемых объектов.  
Упорядочении вычислений таким образом, чтобы все части кода, способные повлечь сбой, предшествовали первой модификации объекта.  
Выполнении операции над временной копией объекта и замене содержимого объекта содержимым копии по завершении операции.  
Написание специального кода восстановления (recovery code), который перехватывает сбой, возникающий в ходе выполнения операции, и заставляет объект вернуться в состояние, в котором он находился до начала операции.  
**Источник.** Java: эффективное программирование, 3-е изд. : Блох, Джошуа 2019. – 375-378 с.  

67. Приведите пример, когда отсутствие транзакционности в исключениях, приводит к сохранению ссылки на объект в неверном состоянии.  
**Ответ.**  
```java  
public Object pop() {  
    if (size == 0)   
        throw new EmptyStackException();  
    Object result = elements[—size];  
    elements[size] = null; // Удаление устаревшей ссылки   
    return result;  
}  
```  
Если убрать начальную проверку размера, метод все равно будет генерировать исключение при попытке получить элемент из пустого стека. Однако при этом он будет оставлять поле size в несогласованном (отрицательном) состоянии, приводя к тому, что сбоем будет завершаться вызов любого метода этого объекта.  
**Источник.** Java: эффективное программирование, 3-е изд. : Блох, Джошуа 2019. – 377 с.  

68. Необходимо создать коллекцию из результатов тестов, находящихся в валидном файле src/in.csv.  
Пример файла  
cool;75;90  
clever;68;95  
looser;30;48  
Является ли код, реализующий задание, антипаттерном?   
Обоснуйте ответ.   
```java   
public class Runner {  
        	public static void main(String[] args) {  
                    	List<Trial> trials = new ArrayList<Trial>();  
                    	try(Scanner sc = new Scanner(new FileReader("src/in.csv"))) {  
                               	while(sc.hasNext()) {  
                                           	Trial trial = getTrial(sc);  
                                           	trials.add(trial);  
                               	}  
                               	printTrials(trials);  
                    	} catch (FileNotFoundException e) {  
                               	System.out.println(Constants.ERROR_FILE_FOUND);  
                    	}  
        	}  
        	private static Trial getTrial(Scanner sc) {  
                    	String csvLine = sc.nextLine();  
                    	String[] values = csvLine.split(Constants.DELIMETER);   	  
                    	try {  
                               	String name = values[Constants.NAME_INDEX];  
                               	int mark1 = Integer.parseInt(values[Constants.MARK1_INDEX]);  
                               	int mark2 = Integer.parseInt(values[Constants.MARK2_INDEX]);  
                   		return new Trial(name, mark1, mark2);  
                    	} catch (CsvLineException e) {  
                               	System.out.println(Constants.ERROR_WRONG_DATA);  
                    	}  
        	}  
}  
```  
**Ответ.** Антипаттерн.   
1 – Метод getTrial в случае сбоя ничего не возвращает, так как в catch нет альтернативного сценария на этот случай.  
2 – Перехват исключения внутри метода и игнорирование ошибки.  

69. Приведите пример кода собственного исключения (реализация в одном классе всего нижеперечисленного). Класс исключения содержит:  
-поле, которым является неправильная строка, считанная из файла (имя csvLine);  
-конструктор по умолчанию, вызывающий конструктор суперкласса;  
-параметризованный конструктор, принимающий экземпляр исключения и неправильную строку, считанную из файла;  
-параметризованный конструктор, принимающий строку с указанием причины исключения и  неправильную строку, считанную из файла;  
-геттер с возвратом неправильной строки;  
-переопределенного метода toString с указанием неправильной строки и метода вывода сообщения об ошибки.  
**Ответ.**  
```java  
public class CsvLineException extends Exception {  
  
    private String csvLine;  
  
    // конструктор по умолчанию, вызывающий конструктор суперкласса  
    public CsvLineException() {  
        super();  
    }  
  
    // параметризованный конструктор, принимающий экземпляр исключения  
    // и неправильную строку, считанную из файла  
    public CsvLineException(Throwable cause, String csvLine) {  
        super(cause);  
        this.csvLine = csvLine;  
    }  
  
    // параметризованный конструктор, принимающий строку с указанием причины исключения  
    // и неправильную строку, считанную из файла  
    public CsvLineException(String message, String csvLine) {  
        super(message);  
        this.csvLine = csvLine;  
    }  
  
    // геттер с возвратом неправильной строки  
    public String getCsvLine() {  
        return csvLine;  
    }  
  
    // переопределенного метода toString с указанием неправильной строки  
    // и метода вывода сообщения об ошибки.  
    @Override  
    public String toString() {  
        return csvLine + super.toString();  
    }  
}  
```  
  
70. Необходимо создать метод для экспорта csv-файла в коллекцию.  
При наличии хотя бы одной ошибки в исходных данных “отменить” создание коллекции.  
Какие антипаттерны содержит следующий код?   
Предложите варианты по избавлению от них.  
```java  
private static List<Trial> getTrials(Scanner sc) {  
List<Trial> trials = new ArrayList<Trial>();  
try {  
while(sc.hasNext()) {  
Trial trial = getTrial(sc);  
trials.add(trial);  
}  
} catch (CsvLineException e) {  
System.err.println(e);  
}  
return trials;  
}  
```  
**Ответ.**  
Метод не реализует поставленную задачу и это же одновременно антипаттерн, так как нет реакции на исключение. В случае сбоя коллекция уже может быть наполнена какими-то экземплярами Trial.  
Самый простой вариант решения это в блоке catch можно заново ссылке trials присвоить новую пустую коллекцию.  
```java  
    private static List<Trial> getTrials(Scanner sc) {  
        List<Trial> trials = new ArrayList<Trial>();  
        try {  
            while (sc.hasNext()) {  
                Trial trial = getTrial(sc);  
                trials.add(trial);  
            }  
        } catch (CsvLineException e) {  
            System.err.println(e);  
            trials = new ArrayList<Trial>();  
        }  
        return trials;  
    }  
```  
  
72. Создать метод для экспорта данных в коллекцию из последовательного источника экземпляров Trial.  
См. код ниже.  
Его необходимо дополнить, чтобы происходила обработка следующих исключительных ситуаций:  
1. 	Файл не найден.  
2. 	Ошибка в csv строке.  
Примечание: код не должен нарушать принцип “верхние уровни приложения должны перехватывать исключения нижних уровней и, в свою очередь, генерировать исключения, которые можно пояснить в терминах абстракции верхнего уровня”  
См. Блох, Д. Java эффективное программирование. 3-е издание. Глава 10 Исключения. Стр 370.  
Считается, что классы для исключений созданы и имеют необходимый функционал.  
```java  
//начало кода, реализующего задание  
//---  
interface TrialProvidable {  
boolean hasTrial();  
Trial getTrial();  
}  

public class TrialCsvImpl implements TrialProvidable {  
private Scanner sc;  
public CsvImpl(String csvName) {            	  
sc = new Scanner(new FileReader(csvName));  
}  
public boolean hasTrial() {             	  
return sc.hasNextLine();  
}  
public Trial getTrial() {  
// get Trial instance from csv line  
return trial;  
}  
}  

public class Runner {  
private static List<Trial> getTrials(TrialProvidable trialProvider) {  
List<Trial> trials = new ArrayList<Trial>();  
while(trialProvider.hasTrial()) {  
Trial trial = trialProvider.getTrial();  
trials.add(trial);  
}  
return trials;  
}  

public static void main(String[] args) {  
TrialProvidable trialProvider = null;  
try {  
if("csv".equals(args[0])) {  
trialProvider = new TrialCsvImpl("src/in.csv");  
} else {  
trialProvider = new TrialDBImpl();  
}  
List<Trial> trials = getTrials(trialProvider);  
…  
} finally {  
if (trialProvider != null) {  
trialProvider.close();  
}  
}  
}  
}  
//---  
//конец кода, реализующего задание  
```  
**Ответ.**  
```java  
public interface TrialProvidable {  
    boolean hasTrial();  
    Trial getTrial() throws CsvLineException;  
    void close();  
}  
  
public class TrialCsvImpl implements TrialProvidable {  
    private Scanner sc;  
  
    public TrialCsvImpl(String csvName) {  
        try {  
            sc = new Scanner(new FileReader(csvName));  
        } catch (FileNotFoundException e) {  
            e.printStackTrace();  
        }  
    }  
  
    @Override  
    public boolean hasTrial() {  
        return sc.hasNextLine();  
    }  
  
    @Override  
    public Trial getTrial() throws CsvLineException {  
        Trial trial = null;  
        String line = sc.nextLine();  
        try {  
            String name = sc.next();  
            int age = (int) Integer.parseInt(sc.next());  
            trial = new Trial(name, age);  
        } catch (NumberFormatException e) {  
            throw new CsvLineException(e.getMessage(), line);  
        }  
        return trial;  
    }  
  
    @Override  
    public void close() {  
        sc.close();      
    }  
}  
  
public class Runner {  
  
    private static List<Trial> getTrials(TrialProvidable trialProvider) {  
        List<Trial> trials = new ArrayList<Trial>();  
        while (trialProvider.hasTrial()) {  
            Trial trial = null;  
            try {  
                trial = trialProvider.getTrial();  
            } catch (CsvLineException e) {  
                e.printStackTrace();  
            }  
            if (trial != null) {  
                trials.add(trial);  
            }  
        }  
        return trials;  
    }  
  
    public static void main(String[] args) {  
        TrialProvidable trialProvider = null;  
        try {  
            if ("csv".equals(args[0])) {  
                trialProvider = new TrialCsvImpl("src/in.csv");  
            } else {  
                trialProvider = new TrialDBImpl();  
            }  
            List<Trial> trials = getTrials(trialProvider);  
//          ...  
        } finally {  
            if (trialProvider != null) {  
                trialProvider.close();  
            }  
        }  
    }  
}  
```  
