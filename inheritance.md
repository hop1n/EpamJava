Как по терминологии Java называются базовый класс и наследуемый класс?
Ответ. Согласно терминологии Java, базовый класс называется суперкласс (базовый, родительский), а наследуемый класс - подкласс (производный, дочерний).
Источник. И. Блинов. Java. Методы программирования. с. 97.
https://docs.oracle.com/javase/tutorial/java/IandI/subclasses.html

Какой класс является родительским для всех классов?
Ответ. Родительским для всех классов является класс java.lang.Object
Источник. И. Блинов. Java. Методы программирования. с. 97.
 https://docs.oracle.com/javase/tutorial/java/IandI/subclasses.html
 
Какой класс является родительским для всех перечислений?
Ответ. Родительским для всех перечислений является класс java.lang.Enum
Источник. И. Блинов. Java. Методы программирования. с. 76.
https://docs.oracle.com/javase/7/docs/api/java/lang/Enum.html

Какой интерфейс является родительским для всех интерфейсов?
Ответ. Интерфейсы не имеют общего предка
Источник. https://docs.oracle.com/javase/8/docs/api/java/lang/package-tree.html
Хабибуллин И.Ш. “Самоучитель Java”, 2001, с.107
 
Какому условию должны удовлетворять две сущности физического мира, чтобы соответствующие им классы были связаны отношением наследования?
Ответ. Сущность 1 вступает в отношение наследования к сущности 2 в том случае, если сущность 1 является частным случаем сущности 2 (выполняется отношение “is-a”).
Источник. http://skipy.ru/philosophy/inheritance.html 

В чем смысл конструкции super?
Перечислите случаи, когда используется конструкция  super.
В каких случаях можно обойтись без неё, т.е. заменить другими синтаксическими
возможностями. Если можно, то каким образом?
Ответ. Ключевое слово super применяется для обращения к конструктору суперкласса и для доступа к полю или методу суперкласса. 
1.	Явный вызов конструктора суперкласса из подкласса (только в качестве первой строки кода и только один раз). Можно заменить с помощью дублирования кода конструктора суперкласса, если позволит инкапсуляция. В любом случае это антипаттерн. 
2.	Доступ из подкласса к переопределённому методу или перекрытому полю суперкласса (super.overrideMethod()). Причем, если в суперклассе этот метод не определен, то будет осуществляться поиск по цепочке наследования до тех пор, пока он не будет найден. Во всех случаях с использованием super можно обратиться только к ближайшему суперклассу, т. е. «перескочить» через суперкласс, чтобы обратиться к его суперклассу, невозможно. В случае переопределенных методов полноценно заменить конструкцию super нельзя. Сокрытие же полей не рекомендуется. 
3.	Wildcard (метасимвольные аргументы, маски) в дженериках: List <? super Integer>. Заменить нельзя.
Источники. И.Н. Блинов, В.С. Романчик. Java Методы программирования 2013, с.102
https://docs.oracle.com/javase/tutorial/java/generics/lowerBounded.html 

Можно ли одновременно использовать this() и super() в конструкторе? Поясните ответ.
Ответ. Нет. Инструкция this(), как и инструкция super(), должна быть единственной в вызывающем конструкторе и быть первой по счету выполняемой операцией, т. е. обращение к конструктору суперкласса (собственного класса) становится невозможным.
Источник. И. Блинов. Java. Методы программирования. с. 103.
https://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.8.7

Дан код. 
class SomeClass() {
	...
	public SomeClass() {
		doSmth();
	}
	protected void doSmth() {
		...
	}
}
Это потенциальный антипаттерн. Почему?
Ответ. Конструкторы класса не должны вызывать переопределяемые методы, непосредственно или опосредованно. Нарушение этого правила может привести к неправильной работе программы. Конструктор суперкласса выполняется прежде конструктора подкласса, а потому переопределяемый метод в подклассе будет вызываться перед запуском конструктора этого подкласса. И если переопределенный метод зависит от инициализации, которую осуществляет конструктор подкласса, то этот метод будет работать совсем не так, как ожидалось. А скобки после названия класса вызовут ошибку при запуске данного класса.
Источник. Д. Блох. Effective Java. Статья 17.
Java practices. Constructors shouldn't call overridables.

Если класс реализует некоторый интерфейс, то необходимо ли в нем определить все методы, объявленные в интерфейсе?
Ответ. Не обязательно. Если класс реализует интерфейс, но полностью не реализует его методы, то класс должен быть объявлен абстрактным. Иначе - синтаксическая ошибка.
Источник. https://docs.oracle.com/javase/tutorial/java/IandI/abstract.html 


Для каких целей необходим интерфейс, в котором не объявлено ни одного метода?
Ответ. Интерфейс, который не содержит ни одного метода, используется в следующих случаях:
1.В качестве маркера для класса (прим. Serializable, Cloneable). Такие интерфейсы не содержат методов. Если класс реализует один из таких интерфейсов это означает, что он может реализовать определенный функционал (прим. сериализовать или клонировать свои объекты).  
2. В Java можно объявлять объектные ссылки, которые имеют тип интерфейса, а не класса. Такие переменные могут ссылаться на объекты любых классов, реализующих данный интерфейс. Это может быть использовано для хранения в коллекциях и массивах объектов, имеющих различную иерархию наследования.
3. Для хранения констант. Такие интерфейсы используются для определения общего свойства, либо для определения принадлежности классов, реализующих данный интерфейс, к общей группе.
Источник. И. Блинов. Java. Методы программирования. С. 150.


Можно ли переопределить метод в том же самом классе? Можно ли его перегрузить в этом классе?
Ответ. Переопределить метод (одно и то же имя и сигнатура) в том же самом классе нельзя, потому что компилятор не будет знать к какому из двух методов вы обращаетесь. Перегрузить метод можно сколько угодно раз, потому как в перегруженных методах различное количество и/или тип параметров.
Источник. https://docs.oracle.com/javase/tutorial/java/javaOO/methods.html

Можно ли переопределить метод в подклассе? Можно ли его перегрузить в подклассе?
Ответ. Можно и переопределить, и перегрузить.
Методы с одинаковыми именами, но с различными списком параметров и возвращаемыми значениями могут находиться в разных классах одной цепочки наследования и также будут перегруженными. Если объявление метода подкласса полностью, включая параметры, совпадает с объявлением метода суперкласса (порождающего класса), то метод подкласса переопределяет (overrides) метод суперкласса.
Источник. И. Блинов. Java. Методы программирования. с. 103.

Можно ли переопределить статический метод? Поясните ответ.
Ответ. Нет. Для статических методов принципы «позднего связывания» не используются. Динамический полиморфизм к статическим методам класса неприменим, так как обращение к статическому атрибуту или методу осуществляется по типу ссылки, а не по типу объекта, через который производится обращение. Версия вызываемого статического метода всегда определяется на этапе компиляции. При использовании ссылки для доступа к статическому члену компилятор при выборе метода учитывает тип ссылки, а не тип объекта, ей присвоенного.
Источник. И. Блинов. Java. Методы программирования. с. 107.

Как запретить переопределение метода в подклассе? Назовите 2 способа.
Ответ. 
1. Использовать ключевое слово final в объявлении метода, чтобы указать, что метод не может быть переопределен подклассами. Разработчик, объявляющий метод как final, считает, что его версия метода окончательна и не может иметь другой реализации.
2. Использовать модификатор доступа private, что делает невозможным переопределение соответствующего метода в подклассе.
Источники. https://docs.oracle.com/javase/tutorial/java/IandI/final.html  
https://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html 

С помощью какого механизма реализуется полиморфизм в Java?
Ответ. С помощью механизма «позднего связывания».
Источник. И. Блинов. Java. Методы программирования. с. 97.

Верно ли утверждение, что если есть ссылка на объект подкласса, то тем самым есть ссылка на объект суперкласса? Если да, то как ее получить?
Ответ. Утверждение не верно. Рассмотрим два класса: суперкласс А и подкласс В. Т.к. В наследуется от А, то экземпляр класса В и есть экземпляр класса А. Ссылка на объект класса А не хранится. 
Источник. http://qaru.site/questions/511262/why-cant-reference-to-child-class-object-refer-to-the-parent-class-object


SmallEntity и BigEntity - это подклассы Entity.
Можно ли отрефакторить данный код? Если да, то выполните. 
class EntityFactory { 
public static Entity getEntity(int num) {
		switch(num) {
			case 2: return new Entity();
			case 3: return new SmallEntity();
			case 4: return new BigEntity();
			default: throw new IllegalArgumentException();
		}
}
}
Ответ. Можно отрефакторить в шаблон Factory Method следующим образом:
public enum EntityFactory {

    ENTITY {
        @Override
        public Entity getEntity() {
            return new Entity();
        }
    },
    SMALL_ENTITY {
        @Override
        public Entity getEntity() {
            return new SmallEntity();
        }
    },
    BIG_ENTITY {
        @Override
        public Entity getEntity() {
            return new BigEntity();
        }
    };

    public abstract Entity getEntity();

}

Можно ли отрефакторить данный код? Если да, то выполните. 
class Entity { 
	...
	private String action;
	public void doSmth() {
		switch(action) {
			case "sing-solo": singSolo(); break;
			case "sing-duet": singDuet(); break;
			case "dance": dance();
		}
	}
	private void singSolo() {
		...
	}
	private void singDuet() {
		...
	}
	private void dance() {
		...
	}
}
Ответ. Можно отрефакторить внутренний алгоритм в операторе switch:
class Entity { 
    ...
    private String action;
    public void doSmth() {
      switch(action) {
        case "sing-solo": singSolo(); break;
        case "sing-duet": singDuet(); break;
        case "dance": dance(); break;
        default: System.out.println("Not implemented action: " + action);
	   }
	}
	private void singSolo() {
		...
	}
	private void singDuet() {
		...
	}
	private void dance() {
		...
	}
}


Пусть А - абстрактный класс, а - ссылка на А, класс В расширяет класс А. Можно ли создать объект класса В по ссылке а?
Ответ. Да, можно создать.
Источник. И. Блинов. Java. Методы программирования. с. 108.

Пусть I - интерфейс, i - ссылка на I, b - ссылка на B, класс В реализует интерфейс I. Можно ли создать объект класса В по ссылке i? Можно ли выполнить операции:
1. b = i; ?
2. i = b; ?
Ответ. Да, можно создать. 
1. Без явного приведения к типу B нельзя.
2. Да, можно.
Источник. И. Блинов. Java. Методы программирования. с. 110.

В чем заключается отличие сравнения принадлежности к классу через операцию instanceof и метод getClass()?
Ответ. C помощью метода getClass() проверяется, принадлежность объекта конкретному классу, тогда как с помощью оператора instanceof — принадлежит ли объект конкретному классу или его наследникам.
Источник. http://qaru.site/questions/74261/instanceof-vs-getclass

Можно ли создать:
1. ссылку на объект абстрактного класса?
2. объект абстрактного класса?
3. ссылку на интерфейс?
4. объект типа интерфейс?
Ответ. 1. Да.
2. Нет.
3. Да.
4. Нет.
Источник. https://docs.oracle.com/javase/tutorial/java/IandI/abstract.html

Может ли класс:
1. реализовывать два интерфейса?
2. расширять два класса?
3. расширять два интерфейса?
4. расширять один класс и реализовывать один интерфейс?
5. расширять сам себя?
Ответ. 1. Да.
2. Нет.
3. Нет.
4. Да.
5. Нет.



Для каких целей используется расширение интерфейса?
Ответ. Если необходимо добавить к ранее созданному интерфейсу новый метод так, чтобы  программы, написанные ранее с осуществлением первоначальной версии интерфейса, не утратили своей работоспособности, то одним из способов сделать это является создание нового интерфейса, который будет расширять (extends) прежний. При этом у пользователей (программистов) появится выбор: использовать старую версию интерфейса или обновить свою программу и использовать новую версию.
Источник. http://docs.oracle.com/javase/tutorial/java/IandI/nogrow.html

Могут ли в интерфейсе быть поля?
Ответ. Да, но только инициализированные константы. (public static final)
Источник. И. Блинов. Java. Промышленное программирование. с. 152.

Можно ли в интерфейсе
1. объявить метод с пакетным уровнем доступа?
2. объявить конструктор?
3. определить конструктор?
Ответ. 1. Нет. По умолчанию доступ для методов в интерфейсах — публичный абстрактный.
2. Нет.
3. Нет.
Источник. https://docs.oracle.com/javase/specs/jls/se11/html/jls-9.html#jls-9.4

Можно ли интерфейс объявить финальным? Поясните ответ. 
Ответ. Нет, т.к. интерфейсы должны быть реализованы классами. Интерфейс представляет собой поведение, а не реализацию, поэтому для него нет никакого смысла быть финальным.
Источник: https://docs.oracle.com/javase/tutorial/java/IandI/createinterface.html 

Можно ли в интерфейсе объявить статический метод? Поясните ответ. 
Ответ. В интерфейсе все методы неявно объявляются как abstract. Статические методы не могут быть абстрактными. Т. к. статические методы не могут быть переопределены (из-за привязки к типу класса, а не к объекту класса), то они должны сразу иметь реализацию.
Начиная с JDK8, интерфейсы могут иметь методы с реализацией, обозначаемые default, а также статические методы. Таким образом становится возможным применение статических методов с реализацией в интерфейсе.
Источник. https://docs.oracle.com/javase/specs/jls/se8/html/jls-9.html#jls-9.4

Можно ли вызвать статический метод через объектную ссылку? Поясните ответ.
Ответ. Можно, но вызов статических методов через объект считается нетипичным и нарушающим смысл статического определения. 
Источник. И. Блинов. Java. Промышленное программирование. с. 107-108.

Можно ли создать экземпляр класса, у которого есть абстрактный метод? Если да, то зачем?
Ответ. Если класс имеет хотя бы один абстрактный метод, то его также следует объявить абстрактным. Создавать экземпляр абстрактного класса нельзя, можно объявить только ссылку на абстрактный класс, но инициализировать ее необходимо объектом какого-то подкласса, реализующим все абстрактные методы.
Источник. И. Блинов. Java. Промышленное программирование. с. 108.

Должен ли иметь абстрактный класс хотя бы один абстрактный метод? Если нет, то зачем объявлять такой класс абстрактным?
Ответ. К абстрактным классам нет требования иметь хотя бы один абстрактный метод. 
Объявление класса абстрактным запрещает создавать экземпляры такого класса. 
Он может понадобиться, например, для выделения общих “состояний” (полей) у нескольких подклассов. 
Источник. https://docs.oracle.com/javase/tutorial/java/IandI/abstract.html 

Что означает ключевое слово final в следующих конструкциях?
1.
public final class SomeClass() { }
2.
public class SomeClass() {
public final void doSmth();
}
Ответ. 1. Нельзя создать подкласс для класса SomeClass, объявленного со модификатором final.
2. Если у суперкласса SomeClass есть подклассы, то нельзя переопределить метод в подклассе, если в суперклассе он объявлен с модификатором final. Данным способом можно исключить подмену реализации метода в классе-наследнике.
Источник. И. Блинов. Java. Промышленное программирование. с. 100-101.

Можно ли объявить метод одновременно финальным и абстрактным? Поясните ответ.
Ответ. Нет, так как эти модификаторы по отношению к методам в плане наследования противоречат друг другу. Абстрактный метод наследуется, а финальный — нет.
Так же, это противоположные по сути понятия из-за того, что финальный метод запрещает своё переопределение, а абстрактный требует реализацию.
Источник. https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.4.3

К каким методам неприменимы принципы позднего связывания? Почему?
Ответ. К статическим методам и методам с модификаторами private и final. Вышеназванные методы по своей сути являются не переопределяемыми, а при их вызове используется информация о типе ссылочной переменной, а не конкретный объект. 
Источник. И. Блинов. Java. Промышленное программирование. с. 88.
http://pr0java.blogspot.com/2015/07/final.html
http://www.linkex.ru/java/final-no-overriding.php
https://javarush.ru/groups/posts/439-razlichija-mezhdu-rannim-i-pozdnim-svjazihvaniem-v-java

В чем заключается отличие между ранним и поздним связыванием?
Ответ. Раннее связывание - механизм, определяющий версию метода на этапе компиляции.
Позднее связывание - механизм, который в процессе выполнения программы определяет принадлежность объекта конкретному классу и производит вызов метода, относящегося к классу, объект которого был использован.
Источник. И. Блинов. Java. Методы программирования. С. 13.

